<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN""http://www.w3.org/TR/REC-html40/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc on Thu Nov 27 13:54:34 EET 2003 -->
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<TITLE>
Graphics3D (Mobile 3D Graphics API (M3G))
</TITLE>
<META NAME="keywords" CONTENT="javax.microedition.m3g.Graphics3D,Graphics3D class">
<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">
</HEAD>
<SCRIPT>
function asd()
{
parent.document.title="Graphics3D (Mobile 3D Graphics API (M3G))";
}
</SCRIPT>
<BODY BGCOLOR="white" onload="asd();">

<!-- ========== START OF NAVBAR ========== -->
<A NAME="navbar_top"><!-- --></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Graphics3D.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<EM><B>Nov 19, 2003</B></EM></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../javax/microedition/m3g/Fog.html"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../javax/microedition/m3g/Group.html"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html" TARGET="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Graphics3D.html" TARGET="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;
<SCRIPT>
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html" TARGET=""><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
<A HREF="../../../allclasses-noframe.html" TARGET=""><B>All Classes</B></A>
</NOSCRIPT>
</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<!-- =========== END OF NAVBAR =========== -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
javax.microedition.m3g</FONT>
<BR>
Class Graphics3D</H2>
<PRE>
java.lang.Object
  |
  +--<B>javax.microedition.m3g.Graphics3D</B>
</PRE>
<HR>
<DL>
<DT>public class <B>Graphics3D</B><DT>extends java.lang.Object</DL>

<P>
<p>A singleton 3D graphics context that can be bound to a rendering target.
All rendering is done through the <code>render</code> methods in this class,
including the rendering of World objects. There is no other way to draw
anything in this API.</p>

<h3>Quick introduction</h3>

<p>Using the Graphics3D is very straightforward. The application only
needs to obtain the Graphics3D instance (there is only one), bind a
target to it, render everything, and release the target. This is shown
in the code fragment below.</p>

<blockquote><pre>
public class MyCanvas extends Canvas
{
   Graphics3D myG3D = Graphics3D.getInstance();
   
   public void paint(Graphics g) {
   try {
      myG3D.bindTarget(g);
      ... update the scene ...
      ... render the scene ...
   } finally {
      myG3D.releaseTarget();
   }
}</pre>
</blockquote>

<h3>Immediate mode and retained mode rendering</h3>

<p>There are four different <code>render</code> methods, operating at
different levels of granularity. The first method is for rendering an
entire World. When this method is used, we say that the API operates in
<i>retained mode</i>. The second method is for rendering scene graph
nodes, including Groups. The third and fourth methods are for rendering
an individual submesh. When the node and submesh rendering methods are
used, the API is said to operate in <i>immediate mode</i>.</p>

<p>There is a <i>current camera</i> and an array of <i>current lights</i>
in Graphics3D. These are used by the immediate mode rendering methods only.
The retained mode rendering method <code>render(World)</code> uses the camera
and lights that are specified in the World itself, ignoring the Graphics3D
camera and lights. Instead, <code>render(World)</code> <i>replaces</i> the
Graphics3D current camera and lights with the active camera and lights in the
rendered World. This allows subsequent immediate mode rendering to utilize
the same camera and lighting setup as the World.</p>

<h3>Rendering targets</h3>

<p>Before rendering anything or even clearing the screen, the
application must bind a <i>rendering target</i> to this Graphics3D,
using the <code>bindTarget</code> method. When finished with rendering
a frame, the application must release the rendering target by calling
the <code>releaseTarget</code> method. Implementations may queue
rendering commands and only execute them when the target is released.</p>

<p>The rendering target can be either a Graphics object or an Image2D.
The type of the Graphics object is specific to the Java profile that
this API is implemented on. In case of the MID profile, it must be a
<code>javax.microedition.lcdui.Graphics</code> object, and it may be
associated with a Canvas, mutable Image, or CustomItem.</p>

<p>Once a rendering target is bound to the Graphics3D, all rendering
will end up in the color buffer of its rendering target until
<code>releaseTarget</code> is called. The contents of the rendering
target, after releasing it, will be equal to what they were before
the target was bound, augmented with any 3D rendering performed while
it was bound.</p>

<p>There can be only one rendering target bound to the Graphics3D at a
time. Also, a bound rendering target should not be accessed via any
other interface than the host Graphics3D. This is not enforced, but
the results are unpredictable otherwise. For example, the following
scenarios will result in unpredictable output:</p>

<ul>
<li>2D graphics is rendered via MIDP into a bound Image or Canvas.</li>
<li>A bound Image is read from by the application or the MIDP
    implementation.</li>
<li>A bound Image2D is used by a Graphics3D <code>render</code> method.</li>
</ul>

<p>The contents of the depth buffer are unspecified after
<code>bindTarget</code>, and they are discarded after
<code>releaseTarget</code>. In order to clear depth buffer contents
(and color buffer contents, if so desired) after binding a rendering
target, the application must call the <code>clear</code> method,
either explicitly, or implicitly by rendering a World.</p>

<H3>Origin translation and clipping</H3>

<p>The viewport can be freely positioned relative to the rendering target,
without releasing and re-binding the target. The position of the viewport
is specified relative to the origin of the rendering target. For Graphics
targets, this is the origin in effect when calling <code>bindTarget</code>;
for Image2D targets, the origin is always at the top left corner. Changing
the origin of a bound Graphics object has no effect.</p>

<p>All 3D rendering is clipped to visible part of the viewport, that is,
the intersection of the viewport specified in <code>setViewport</code>
and the rendering target clip rectangle. Rendering operations (including
<code>clear</code>) must not touch pixels falling outside of the visible
part of the viewport. This is illustrated in the figure below.</p>

<center><img src="./doc-files/Graphics3D-clipping.png"/></center>

<p>For Graphics targets, the clipping rectangle is the MIDP/AWT clipping
rectangle that is in effect when calling <code>bindTarget</code>. Similar
to the origin, changing the clipping rectangle of a bound Graphics object
has no effect. For Image2D targets, the clipping rectangle comprises all
pixels in the target image.</p>

<p>Origin translation and clipping are independent of the viewport and
projection transformations, as well as rasterization. All other parameters
being equal, rendering calls must produce the same pixels (prior to clipping)
into the area bounded by the viewport regardless of the position of the
viewport or the target clipping rectangle.</p>

<p>Note that when we refer to the viewport in this specification, we
occasionally mean only the visible part of it. If it is not obvious
from the context whether we mean the full viewport or just the visible
portion, we state that explicitly.</p>

<h3><a name="hints">Rendering quality hints</a></h3>

<p>In some situations, image quality might be more important for an application
than rendering speed or memory usage. Some applications might also want to
increase or decrease the image quality based on device capabilities. Some
might go so far as to dynamically adjust the quality; for instance, by
displaying freeze frames or slow-motion sequences in higher quality.</p>

<p>There are three global options in Graphics3D that allow applications
to indicate a preference for higher rendering quality at the expense of
slower speed and/or extra memory usage. These are the following:</p>

<ul>
<p><li><b>Antialiasing</b>. Specifies that antialiasing should be used to
increase the perceived resolution of the screen. No particular method of
antialiasing is mandated. However, it is strongly recommended that the
method be independent of drawing order, and fast enough to operate at
interactive frame rates. If the chosen method requires post-processing
per frame, that can be done in <code>releaseTarget</code>.</li></p>

<p><li><b>Dithering</b>. Specifies that dithering should be used to increase
the perceived color depth of the screen. No particular method of dithering
is mandated. However, the method should be optimized for animated content
(as opposed to still images) and be able to operate at interactive frame
rates. For example, ordered dithering is recommended over error diffusion.
Implementations may choose to do the dithering at rendering time (per pixel)
or as a post-process (upon <code>releaseTarget</code>).</li></p>

<p><li><b>True color rendering</b>. Specifies that rendering should be done
with an internal color depth higher than what is supported by the device.
For example, on a device with an RGB565 display, rendering could be done
into an RGBA8 back buffer, truncating the pixels to 16 bits only upon
<code>releaseTarget</code>. True color rendering is especially useful
when combined with dithering.</li></p>
</ul>

<p>These options are merely <i>hints</i>, meaning that implementations
may silently ignore them. The application can use <A HREF="../../../javax/microedition/m3g/Graphics3D.html#getProperties()"><CODE>getProperties</CODE></A> to find out whether a particular hint is supported
(acted upon) by the implementation. It is only meaningful for the
implementation to support a hint if that allows the application to
trade performance for quality or vice versa. For example, if dithering
is built into the display hardware and is always enabled, the
implementation should not indicate support for the dithering
hint. Similarly, if the device has a 24 bpp display, the implementation
should not support the true color hint (unless, of course, it uses even
higher color precision in the back buffer).</p>

<p>The rendering quality hints can be set in conjunction with binding a
rendering target, that is, using <A HREF="../../../javax/microedition/m3g/Graphics3D.html#bindTarget(java.lang.Object, boolean, int)"><CODE>bindTarget</CODE></A>.</p>

<H3>Reference pipelines</H3>

<p>The reference geometry and fragment pipelines are shown below. The
mapping of Appearance components to the pipeline stages is also shown.
Note that the ordering of the stages is the same as in OpenGL.</p>

<img src="./doc-files/Graphics3D-geometry.png"/>
<img src="./doc-files/Graphics3D-fragment.png"/>

<p>Implementations may optimize their operation by doing things in a
different order, but only if the result is exactly the same as it
would be with the reference pipelines.</p>

<h3>Implementation guidelines</h3>

<p>See the <a href="package-summary.html#Conventions">package
description</a> for general implementation requirements, definitions
of coordinate systems, and other background information.</p>

<h4>Depth buffer</h4>

<p>The format and bit depth of the depth buffer are specific to each
implementation and are not known to the application. However, the depth
buffer resolution must be at least 8 bits. The contents of the depth
buffer are never exposed through the API, so implementations may choose
not to use a conventional depth buffer at all. However, a conforming
implementation is required to behave <i>as if</i> it were using an
ordinary depth buffer.</p>

<h4>Color buffer</h4>

<p>The resolution of each color channel (R, G, B and A) in the color
buffer must be at least 1 bit. Not all color channels are necessarily
present; for example, the alpha channel is missing from Canvas and
Image targets in MIDP. On a device with a black and white display,
there may be only one channel, representing the luminance. In such
a situation, the conversion of RGB colors into luminance can be done
at any point in the pipeline, provided that the conversion is done
according to the general rules set forth in the package description.</p>

<p>The <code>clear</code> and <code>render(World)</code> methods impose
the restriction that the background image must be in the same format as
the bound rendering target. It is worth highlighting that when bound
to a MIDP Graphics object, the effective format can only be RGB (never
RGBA) due to restrictions in the MIDP specification. It is also true
that the MIDP Graphics object appears to be an RGB target even when the
physical display is in fact monochrome. This reduces the complexity of
application development considerably, since an RGB format image is
valid for any binding to a MIDP target. Other target platforms may
or may not be similarly specified.</p>

<h4>Back buffer</h4>

<p>It is intentionally unspecified whether a separate back buffer should
be allocated for colors or not. Instead, we leave the implementation to
decide which mode of operation is the most efficient, or which produces
the best quality, according to the screen dimensions and speed versus
quality preferences given by the application.</p>

<p>The decision whether to allocate any back buffer memory should be made
at the latest when a new rendering target is first bound to the Graphics3D
object. A previously bound rendering target is considered to be "new" when
the rendering quality hints or the dimensions of the clipping rectangle
have changed. In the case of a Graphics target, the actual rendering target
is considered to be the Canvas, Image or other surface that the Graphics
is attached to. The motivation for this rule is to guarantee that repeated
rebinding of a rendering target - or several different rendering targets -
will not incur the performance penalty of reallocating back buffer memory.</p>

<p>As an example of when a back buffer may be desired, consider a case
where the application specifies <code>setDitheringEnable(true)</code> and
subsequently binds a Canvas target. If the MIDP native color format is of
low precision (such as RGB444), the implementation may wish to render at a
higher color precision to a back buffer, then dither down to the MIDP native
color format.</p>
<P>

<P>
<DL>
<DT><b>Example:</b><DD><div class="example_title">A code fragment illustrating the usage of Graphics3D.

</div><pre class="example"> <span class="example_modifier">public</span> <span class="example_proclamation">class</span> <span class="example_class">MyCanvas</span> <span class="example_proclamation">extends</span> <span class="example_class">Canvas</span>
{
    <span class="example_class">World</span> myWorld;
    <span class="example_type">int</span> currentTime = 0;
    
    <span class="example_modifier">public</span> <span class="example_class">MyCanvas</span>() <span class="example_proclamation">throws</span> <span class="example_class">IOException</span> {
   
        <span class="example_comment">// Load an entire World. Proper exception handling is omitted</span>
        <span class="example_comment">// for clarity; see the class description of Loader for a more</span>
        <span class="example_comment">// elaborate example.</span>
    
        <span class="example_class">Object</span>3D[] objects = <span class="example_class">Loader</span>.load(<span class="example_string">"http://www.example.com/myscene.m3g"</span>);
        myWorld = (<span class="example_class">World</span>) objects[0];
    }
    
    <span class="example_comment">// The paint method is called by MIDP after the application has issued</span>
    <span class="example_comment">// a repaint request. We draw a new frame on this Canvas by binding the</span>
    <span class="example_comment">// current Graphics object as the target, then rendering, and finally</span>
    <span class="example_comment">// releasing the target.</span>
    
    <span class="example_modifier">protected</span> <span class="example_type">void</span> paint(<span class="example_class">Graphics</span> g) {
 
        <span class="example_comment">// Get the singleton Graphics3D instance that is associated</span>
        <span class="example_comment">// with this midlet.</span>
        
        <span class="example_class">Graphics</span>3D g3d = <span class="example_class">Graphics</span>3D.getInstance();
        
        <span class="example_comment">// Bind the 3D graphics context to the given MIDP Graphics</span>
        <span class="example_comment">// object. The viewport will cover the whole of this Canvas.</span>
 
        g3d.bindTarget(g);
 
        <span class="example_comment">// Apply animations, render the scene and release the Graphics.</span>
      
        myWorld.animate(currentTime);
        g3d.render(myWorld);    <span class="example_comment">// render a view from the active camera</span>
        g3d.releaseTarget();    <span class="example_comment">// flush the rendered image</span>
        currentTime += 50;      <span class="example_comment">// assume we can handle 20 frames per second</span>
    }
}</pre></DD></DD></DL>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->


<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Field Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Graphics3D.html#ANTIALIAS">ANTIALIAS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A parameter to <code>bindTarget</code>, specifying that
 antialiasing should be turned on. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Graphics3D.html#DITHER">DITHER</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A parameter to <code>bindTarget</code>, specifying that
 dithering should be turned on. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Graphics3D.html#TRUE_COLOR">TRUE_COLOR</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A parameter to <code>bindTarget</code>, specifying that true
 color rendering should be turned on. </TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->


<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Method Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Graphics3D.html#addLight(javax.microedition.m3g.Light, javax.microedition.m3g.Transform)">addLight</A></B>(<A HREF="../../../javax/microedition/m3g/Light.html">Light</A>&nbsp;light,
         <A HREF="../../../javax/microedition/m3g/Transform.html">Transform</A>&nbsp;transform)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Binds a Light to use in subsequent immediate mode rendering.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Graphics3D.html#bindTarget(java.lang.Object)">bindTarget</A></B>(java.lang.Object&nbsp;target)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Binds the given Graphics or mutable Image2D as the rendering target
 of this Graphics3D. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Graphics3D.html#bindTarget(java.lang.Object, boolean, int)">bindTarget</A></B>(java.lang.Object&nbsp;target,
           boolean&nbsp;depthBuffer,
           int&nbsp;hints)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Binds the given Graphics or mutable Image2D as the rendering target
 of this Graphics3D. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Graphics3D.html#clear(javax.microedition.m3g.Background)">clear</A></B>(<A HREF="../../../javax/microedition/m3g/Background.html">Background</A>&nbsp;background)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Clears the viewport as specified in the given Background object. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../javax/microedition/m3g/Graphics3D.html">Graphics3D</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Graphics3D.html#getInstance()">getInstance</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves the singleton Graphics3D instance that is associated with
 this application. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.util.Hashtable</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Graphics3D.html#getProperties()">getProperties</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves implementation specific properties. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Graphics3D.html#releaseTarget()">releaseTarget</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Flushes the rendered 3D image to the currently bound target and
 then releases the target. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Graphics3D.html#render(javax.microedition.m3g.Node, javax.microedition.m3g.Transform)">render</A></B>(<A HREF="../../../javax/microedition/m3g/Node.html">Node</A>&nbsp;node,
       <A HREF="../../../javax/microedition/m3g/Transform.html">Transform</A>&nbsp;transform)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Renders the given Sprite3D, Mesh, or Group node with the given
 transformation from local coordinates to world coordinates. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Graphics3D.html#render(javax.microedition.m3g.VertexBuffer, javax.microedition.m3g.IndexBuffer, javax.microedition.m3g.Appearance, javax.microedition.m3g.Transform)">render</A></B>(<A HREF="../../../javax/microedition/m3g/VertexBuffer.html">VertexBuffer</A>&nbsp;vertices,
       <A HREF="../../../javax/microedition/m3g/IndexBuffer.html">IndexBuffer</A>&nbsp;triangles,
       <A HREF="../../../javax/microedition/m3g/Appearance.html">Appearance</A>&nbsp;appearance,
       <A HREF="../../../javax/microedition/m3g/Transform.html">Transform</A>&nbsp;transform)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Renders the given submesh with the given transformation from
 local coordinates to world coordinates. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Graphics3D.html#render(javax.microedition.m3g.VertexBuffer, javax.microedition.m3g.IndexBuffer, javax.microedition.m3g.Appearance, javax.microedition.m3g.Transform, int)">render</A></B>(<A HREF="../../../javax/microedition/m3g/VertexBuffer.html">VertexBuffer</A>&nbsp;vertices,
       <A HREF="../../../javax/microedition/m3g/IndexBuffer.html">IndexBuffer</A>&nbsp;triangles,
       <A HREF="../../../javax/microedition/m3g/Appearance.html">Appearance</A>&nbsp;appearance,
       <A HREF="../../../javax/microedition/m3g/Transform.html">Transform</A>&nbsp;transform,
       int&nbsp;scope)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Renders the given submesh with the given scope and the given
 transformation from local coordinates to world coordinates.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Graphics3D.html#render(javax.microedition.m3g.World)">render</A></B>(<A HREF="../../../javax/microedition/m3g/World.html">World</A>&nbsp;world)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Renders an image of <code>world</code> as viewed by the
 active camera of that World. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Graphics3D.html#resetLights()">resetLights</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Clears the array of current Lights.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Graphics3D.html#setCamera(javax.microedition.m3g.Camera, javax.microedition.m3g.Transform)">setCamera</A></B>(<A HREF="../../../javax/microedition/m3g/Camera.html">Camera</A>&nbsp;camera,
          <A HREF="../../../javax/microedition/m3g/Transform.html">Transform</A>&nbsp;transform)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the Camera to use in subsequent immediate mode rendering. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Graphics3D.html#setDepthRange(float, float)">setDepthRange</A></B>(float&nbsp;near,
              float&nbsp;far)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specifies the mapping of depth values from normalized device
 coordinates to window coordinates. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Graphics3D.html#setLight(int, javax.microedition.m3g.Light, javax.microedition.m3g.Transform)">setLight</A></B>(int&nbsp;index,
         <A HREF="../../../javax/microedition/m3g/Light.html">Light</A>&nbsp;light,
         <A HREF="../../../javax/microedition/m3g/Transform.html">Transform</A>&nbsp;transform)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Binds or unbinds a Light for subsequent immediate mode rendering.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Graphics3D.html#setViewport(int, int, int, int)">setViewport</A></B>(int&nbsp;x,
            int&nbsp;y,
            int&nbsp;width,
            int&nbsp;height)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specifies a rectangular viewport on the currently bound
 rendering target. </TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Methods inherited from class java.lang.Object</B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>equals, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Field Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="ANTIALIAS"><!-- --></A><H3>
ANTIALIAS</H3>
<PRE>
public static final int <B>ANTIALIAS</B></PRE>
<DL>
<DD><p>A parameter to <code>bindTarget</code>, specifying that
 antialiasing should be turned on. The application may query
 from <code>getProperties</code> whether this hint is acted upon
 by the implementation.</p>
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#javax.microedition.m3g.Graphics3D.ANTIALIAS">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="DITHER"><!-- --></A><H3>
DITHER</H3>
<PRE>
public static final int <B>DITHER</B></PRE>
<DL>
<DD><p>A parameter to <code>bindTarget</code>, specifying that
 dithering should be turned on. The application may query from
 <code>getProperties</code> whether this hint is acted upon by
 the implementation.</p>
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#javax.microedition.m3g.Graphics3D.DITHER">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="TRUE_COLOR"><!-- --></A><H3>
TRUE_COLOR</H3>
<PRE>
public static final int <B>TRUE_COLOR</B></PRE>
<DL>
<DD><p>A parameter to <code>bindTarget</code>, specifying that true
 color rendering should be turned on. The application may query
 from <code>getProperties</code> whether this hint is acted upon
 by the implementation.</p>
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#javax.microedition.m3g.Graphics3D.TRUE_COLOR">Constant Field Values</A></DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->


<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Method Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="getInstance()"><!-- --></A><H3>
getInstance</H3>
<PRE>
public static final <A HREF="../../../javax/microedition/m3g/Graphics3D.html">Graphics3D</A> <B>getInstance</B>()</PRE>
<DL>
<DD><p>Retrieves the singleton Graphics3D instance that is associated with
 this application. The same instance will be returned every time.</p>

 <p>Initially, the state of the Graphics3D instance is as follows:</p>
 
 <ul>
 <li>viewport : undefined (reset at <code>bindTarget</code>)</li>
 <li>depth range : [0, 1]</li>
 <li>current camera : none</li>
 <li>current lights : none</li>
 </ul>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the Graphics3D instance associated with this application</DL>
</DD>
</DL>
<HR>

<A NAME="bindTarget(java.lang.Object)"><!-- --></A><H3>
bindTarget</H3>
<PRE>
public void <B>bindTarget</B>(java.lang.Object&nbsp;target)</PRE>
<DL>
<DD><p>Binds the given Graphics or mutable Image2D as the rendering target
 of this Graphics3D. The type of the Graphics object depends on the
 Java profile that this specification is implemented on, as follows:</p>
 
 <ul>
 <li><code>java.awt.Graphics</code> on profiles supporting AWT;</li>
 <li><code>javax.microedition.lcdui.Graphics</code> on profiles
     supporting LCDUI;</li>
 <li>either of the above on profiles supporting both AWT and LCDUI.</li>
 </ul>

 <p>The state of this Graphics3D after calling this method will be
 as follows:</p>
 
 <ul>
 <li>rendering target : the given Graphics or Image2D</li>
 <li>viewport : size of the target, or maximum size</li>
 <li>depth buffer : enabled</li>
 <li>antialiasing : disabled</li>
 <li>dithering : disabled</li>
 <li>true color : disabled</li>
 <li>depth range : as before</li>
 <li>current camera : as before</li>
 <li>current lights : as before</li>
 </ul>

 <p>The viewport is set such that its top left corner is at the
 top left corner of the target clipping rectangle, and its
 dimensions are equal to those of the clipping rectangle. However,
 if this would cause the width or height of the viewport to exceed
 its implementation defined maximum, the dimension in question is
 set to the maximum value instead. The maximum viewport size can be
 queried with <code>getProperties</code>.</p>

 <p>Note that this method will not block waiting if another thread
 has already bound a rendering target to this Graphics3D. Instead,
 it will throw an exception. Only one target can be bound at a time,
 and it makes no difference whether that target has been bound from
 the current thread or some other thread.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>target</CODE> - the Image2D or Graphics object to receive the rendered
        image
<DT><B>Throws:</B>
<DD><CODE>java.lang.NullPointerException</CODE> - if <code>target</code> is null
<DD><CODE>java.lang.IllegalStateException</CODE> - if this Graphics3D already has a
         rendering target
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>target</code> is not
         a mutable Image2D object or a Graphics object appropriate
         to the underlying Java profile
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>target</code> is an Image2D
         with an internal format other than <code>RGB</code> or
         <code>RGBA</code><DT><B>See Also:</B><DD><A HREF="../../../javax/microedition/m3g/Graphics3D.html#releaseTarget()"><CODE>releaseTarget()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="bindTarget(java.lang.Object, boolean, int)"><!-- --></A><H3>
bindTarget</H3>
<PRE>
public void <B>bindTarget</B>(java.lang.Object&nbsp;target,
                       boolean&nbsp;depthBuffer,
                       int&nbsp;hints)</PRE>
<DL>
<DD><p>Binds the given Graphics or mutable Image2D as the rendering target
 of this Graphics3D. This method is identical to the simpler variant of
 <code>bindTarget</code>, but allows the depth buffering enable flag and
 the rendering quality hints to be specified. See the class description
 for more information on these.</p>

 <p>If the depth buffer is disabled, depth testing and depth writing
 are implicitly disabled for <i>all</i> objects, regardless of their
 individual CompositingMode settings.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>target</CODE> - the Image2D or Graphics object to receive the
        rendered image<DD><CODE>depthBuffer</CODE> - <i>true</i> to enable depth buffering;
        <i>false</i> to disable<DD><CODE>hints</CODE> - an integer bitmask specifying which rendering quality
        hints to enable, or zero to disable all hints
<DT><B>Throws:</B>
<DD><CODE>java.lang.NullPointerException</CODE> - if <code>target</code> is null
<DD><CODE>java.lang.IllegalStateException</CODE> - if this Graphics3D already has a
         rendering target
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>target</code> is not
         a mutable Image2D object or a Graphics object appropriate
         to the underlying Java profile
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>target</code> is an Image2D
         with an internal format other than <code>RGB</code> or
         <code>RGBA</code>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>hints</code> is not zero
         or an OR bitmask of one or more of <code>ANTIALIAS, DITHER,
         TRUE_COLOR</code><DT><B>See Also:</B><DD><A HREF="../../../javax/microedition/m3g/Graphics3D.html#releaseTarget()"><CODE>releaseTarget()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="releaseTarget()"><!-- --></A><H3>
releaseTarget</H3>
<PRE>
public void <B>releaseTarget</B>()</PRE>
<DL>
<DD><p>Flushes the rendered 3D image to the currently bound target and
 then releases the target. This ensures that the 3D image is actually
 made visible on the target that was set in <code>bindTarget</code>.
 Otherwise, the image may or may not become visible.</p>
<P>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - if this Graphics3D does not have a
         rendering target</DL>
</DD>
</DL>
<HR>

<A NAME="setViewport(int, int, int, int)"><!-- --></A><H3>
setViewport</H3>
<PRE>
public void <B>setViewport</B>(int&nbsp;x,
                        int&nbsp;y,
                        int&nbsp;width,
                        int&nbsp;height)</PRE>
<DL>
<DD><p>Specifies a rectangular viewport on the currently bound
 rendering target. The viewport is the area where the view of
 the current camera will appear. Any parts of the viewport that
 lie outside the boundaries of the target clipping rectangle are
 silently clipped off; however, this must simply discard the
 pixels without affecting projection. The viewport upper left
 corner (x, y) is given relative to the origin for a Graphics
 rendering target, or the upper left corner for an Image2D
 target. Refer to the class description for details.</p>

 <p>The viewport mapping transforms vertices from normalized device
 coordinates (x<sub>ndc</sub>, y<sub>ndc</sub>) to window coordinates
 (x<sub>w</sub>, y<sub>w</sub>) as follows:</p>

 <blockquote>
 x<sub>w</sub> = 0.5 x<sub>ndc</sub> w + o<sub>x</sub><br>
 y<sub>w</sub> = -0.5 y<sub>ndc</sub> h + o<sub>y</sub><br>
 </blockquote>

 <p>where w and h are the width and height of the viewport,
 specified in pixels, and (o<sub>x</sub>, o<sub>y</sub>) is the
 center of the viewport, also in pixels. The center of the
 viewport is obtained from the (x, y) coordinates of the top
 left corner as follows:</p>

 <blockquote>
 o<sub>x</sub> = x + 0.5 w<br>
 o<sub>y</sub> = y + 0.5 h<br>
 </blockquote>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - X coordinate of the viewport upper left corner, in pixels<DD><CODE>y</CODE> - Y coordinate of the viewport upper left corner, in pixels<DD><CODE>width</CODE> - width of the viewport, in pixels<DD><CODE>height</CODE> - height of the viewport, in pixels
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>width</code> or
         <code>height</code> is negative or zero (note that
         <code>x</code> and <code>y</code> may have any value)
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the size of the viewport exceeds the
         implementation defined maximum size in either dimension; the
         maximum size can be queried with <code>getProperties</code></DL>
</DD>
</DL>
<HR>

<A NAME="setDepthRange(float, float)"><!-- --></A><H3>
setDepthRange</H3>
<PRE>
public void <B>setDepthRange</B>(float&nbsp;near,
                          float&nbsp;far)</PRE>
<DL>
<DD><p>Specifies the mapping of depth values from normalized device
 coordinates to window coordinates. Window coordinates are used
 for depth buffering.</p>
 
 <p>Depth values may range from -1 to 1 in normalized device
 coordinates (NDC), and from 0 to 1 in window coordinates. By
 default, the whole [0, 1] range of window coordinates is
 used. This method allows the normalized device coordinates [-1,
 1] to be mapped to a "tighter" interval of window coordinates,
 for example, (0.5, 1].</p>

 <p>Formally, the Z coordinate of a vertex in NDC, z<sub>ndc</sub>,
 is transformed to window coordinates (z<sub>w</sub>) as follows:</p>

 <blockquote>
 z<sub>w</sub> = 0.5 (far - near) (z<sub>ndc</sub> + 1) + near
 </blockquote>

 <p>where <code>near</code> and <code>far</code> are the distances,
 in window coordinates, to the near and far plane of the depth range,
 respectively. Both distances must be in [0, 1]. However, it is not
 necessary for the near plane to be closer than the far plane; inverse
 mappings are also acceptable.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>near</CODE> - distance to the near clipping plane, in window coordinates<DD><CODE>far</CODE> - distance to the far clipping plane, in window coordinates
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>(near &lt; 0) ||
         (near &gt; 1)</code>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>(far &lt; 0) ||
         (far &gt; 1)</code></DL>
</DD>
</DL>
<HR>

<A NAME="clear(javax.microedition.m3g.Background)"><!-- --></A><H3>
clear</H3>
<PRE>
public void <B>clear</B>(<A HREF="../../../javax/microedition/m3g/Background.html">Background</A>&nbsp;background)</PRE>
<DL>
<DD><p>Clears the viewport as specified in the given Background object. If
 the background object is null, the default settings are used. That is,
 the color buffer is cleared to transparent black, and the depth buffer
 to the maximum depth value (1.0).</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>background</CODE> - a Background object defining which buffers to clear
        and how, or null to use the default settings
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the background image in
         <code>background</code> is not in the same format as
         the currently bound rendering target
<DD><CODE>java.lang.IllegalStateException</CODE> - if this Graphics3D does not have a
         rendering target</DL>
</DD>
</DL>
<HR>

<A NAME="render(javax.microedition.m3g.World)"><!-- --></A><H3>
render</H3>
<PRE>
public void <B>render</B>(<A HREF="../../../javax/microedition/m3g/World.html">World</A>&nbsp;world)</PRE>
<DL>
<DD><p>Renders an image of <code>world</code> as viewed by the
 active camera of that World. The node transformation of the
 World is ignored, but its other attributes are respected.</p>

 <p>Contrary to the immediate mode <code>render</code> variants,
 this method automatically clears the color buffer and the depth
 buffer according to the Background settings of the World.</p>

 <p>Prior to rendering, the current camera and lights set in this
 Graphics3D are automatically overwritten with the active camera
 and lights of the World. Upon method return, the lights array
 will contain precisely those Light nodes whose effective rendering
 enable flag is <i>true</i> (see <A HREF="../../../javax/microedition/m3g/Node.html#setRenderingEnable(boolean)"><CODE>Node.setRenderingEnable(boolean)</CODE></A>).
 The Lights are written to the array in undefined order, but such
 that there are no empty slots interleaved within non-empty slots
 and the first Light is at index 0.</p>

 <p>For any node that is rendered, if the transformation from that
 node's local coordinates to the camera space is not invertible,
 the results of lighting and fogging are undefined.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>world</CODE> - the World to render
<DT><B>Throws:</B>
<DD><CODE>java.lang.NullPointerException</CODE> - if <code>world</code> is null
<DD><CODE>java.lang.IllegalStateException</CODE> - if this Graphics3D does not have a
         rendering target
<DD><CODE>java.lang.IllegalStateException</CODE> - if <code>world</code> has no active
         camera, or the active camera is not in that world
<DD><CODE>java.lang.IllegalStateException</CODE> - if the background image of
         <code>world</code> is not in the same format as the
         currently bound rendering target
<DD><CODE>java.lang.IllegalStateException</CODE> - if any Mesh that is rendered violates
         the constraints defined in Mesh, MorphingMesh, SkinnedMesh,
         VertexBuffer, or IndexBuffer
<DD><CODE>java.lang.ArithmeticException</CODE> - if the transformation from the
         active camera of <code>world</code> to the world
         space is uninvertible</DL>
</DD>
</DL>
<HR>

<A NAME="render(javax.microedition.m3g.Node, javax.microedition.m3g.Transform)"><!-- --></A><H3>
render</H3>
<PRE>
public void <B>render</B>(<A HREF="../../../javax/microedition/m3g/Node.html">Node</A>&nbsp;node,
                   <A HREF="../../../javax/microedition/m3g/Transform.html">Transform</A>&nbsp;transform)</PRE>
<DL>
<DD><p>Renders the given Sprite3D, Mesh, or Group node with the given
 transformation from local coordinates to world coordinates. The
 node transformation of the given node is ignored, but its other
 attributes are respected.</p>
 
 <p>Any ancestors of the given node are ignored, as well as their
 transformations and other attributes. The node's descendants, if
 any, are rendered as usual. However, any Camera and Light nodes
 among the descendants are ignored and the camera and lights of
 this Graphics3D are used instead.</p>
 
 <p>The scope masks of the current Lights and Camera are respected,
 as well as the rendering enable flags of the Lights. The rendering
 enable flag of the Camera is ignored, as always.</p>

 <p>Note that Mesh nodes include MorphingMesh and SkinnedMesh nodes,
 and that Group nodes include World nodes. If a World is passed to
 this method, it is simply treated like any other Group and therefore
 any Background, Camera and Light objects it may have are ignored.</p>

 <p>This method does <i>not</i> clear the color and depth buffers;
 the application must explicitly clear them with the <A HREF="../../../javax/microedition/m3g/Graphics3D.html#clear(javax.microedition.m3g.Background)"><CODE>clear</CODE></A> method and/or draw any background graphics beforehand.</p>

 <p>For any node that is rendered, if the transformation from that
 node's local coordinates to the camera space is not invertible, the
 results of lighting and fogging are undefined.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>node</CODE> - the Sprite3D, Mesh, or Group to render<DD><CODE>transform</CODE> - the transformation from the local coordinate
        system of <code>node</code> to world space, or null to
        indicate the identity matrix
<DT><B>Throws:</B>
<DD><CODE>java.lang.NullPointerException</CODE> - if <code>node</code> is null
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>node</code> is not a
         Sprite3D, Mesh, or Group
<DD><CODE>java.lang.IllegalStateException</CODE> - if this Graphics3D does not have
         a rendering target
<DD><CODE>java.lang.IllegalStateException</CODE> - if this Graphics3D does not have
         a current camera
<DD><CODE>java.lang.IllegalStateException</CODE> - if any Mesh that is rendered violates
         the constraints defined in Mesh, MorphingMesh, SkinnedMesh,
         VertexBuffer, or IndexBuffer</DL>
</DD>
</DL>
<HR>

<A NAME="render(javax.microedition.m3g.VertexBuffer, javax.microedition.m3g.IndexBuffer, javax.microedition.m3g.Appearance, javax.microedition.m3g.Transform, int)"><!-- --></A><H3>
render</H3>
<PRE>
public void <B>render</B>(<A HREF="../../../javax/microedition/m3g/VertexBuffer.html">VertexBuffer</A>&nbsp;vertices,
                   <A HREF="../../../javax/microedition/m3g/IndexBuffer.html">IndexBuffer</A>&nbsp;triangles,
                   <A HREF="../../../javax/microedition/m3g/Appearance.html">Appearance</A>&nbsp;appearance,
                   <A HREF="../../../javax/microedition/m3g/Transform.html">Transform</A>&nbsp;transform,
                   int&nbsp;scope)</PRE>
<DL>
<DD><p>Renders the given submesh with the given scope and the given
 transformation from local coordinates to world coordinates.</p>

 <p>The scope masks of the current Lights and Camera are respected,
 as well as the rendering enable flags of the Lights. The rendering
 enable flag of the Camera is ignored, as always.</p>

 <p>If the transformation from local coordinates to the camera
 space is not invertible, the results of lighting and fogging
 are undefined.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>vertices</CODE> - a VertexBuffer defining the vertex attributes<DD><CODE>triangles</CODE> - an IndexBuffer defining the triangle strips<DD><CODE>appearance</CODE> - an Appearance defining the surface properties<DD><CODE>transform</CODE> - the transformation from the local coordinate system of
        <code>vertices</code> to world space, or null to indicate the
        identity matrix<DD><CODE>scope</CODE> - the scope of the submesh; this determines whether the
        submesh is rendered at all, and if it is, which lights are
        used; "-1" makes the scope as wide as possible
<DT><B>Throws:</B>
<DD><CODE>java.lang.NullPointerException</CODE> - if <code>vertices</code> is null
<DD><CODE>java.lang.NullPointerException</CODE> - if <code>triangles</code> is null
<DD><CODE>java.lang.NullPointerException</CODE> - if <code>appearance</code> is null
<DD><CODE>java.lang.IllegalStateException</CODE> - if this Graphics3D does not have
         a rendering target
<DD><CODE>java.lang.IllegalStateException</CODE> - if this Graphics3D does not have
         a current camera
<DD><CODE>java.lang.IllegalStateException</CODE> - if <code>vertices</code> or
         <code>triangles</code> violates the constraints defined
         in VertexBuffer or IndexBuffer</DL>
</DD>
</DL>
<HR>

<A NAME="render(javax.microedition.m3g.VertexBuffer, javax.microedition.m3g.IndexBuffer, javax.microedition.m3g.Appearance, javax.microedition.m3g.Transform)"><!-- --></A><H3>
render</H3>
<PRE>
public void <B>render</B>(<A HREF="../../../javax/microedition/m3g/VertexBuffer.html">VertexBuffer</A>&nbsp;vertices,
                   <A HREF="../../../javax/microedition/m3g/IndexBuffer.html">IndexBuffer</A>&nbsp;triangles,
                   <A HREF="../../../javax/microedition/m3g/Appearance.html">Appearance</A>&nbsp;appearance,
                   <A HREF="../../../javax/microedition/m3g/Transform.html">Transform</A>&nbsp;transform)</PRE>
<DL>
<DD><p>Renders the given submesh with the given transformation from
 local coordinates to world coordinates. This method is exactly
 the same as the other submesh rendering method, except that the
 scope is implicitly set to -1 (the widest possible).</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>vertices</CODE> - a VertexBuffer defining the vertex attributes<DD><CODE>triangles</CODE> - an IndexBuffer defining the triangle strips<DD><CODE>appearance</CODE> - an Appearance defining the surface properties<DD><CODE>transform</CODE> - the transformation from the local coordinate system of
        <code>vertices</code> to world space, or null to indicate the
        identity matrix
<DT><B>Throws:</B>
<DD><CODE>java.lang.NullPointerException</CODE> - if <code>vertices</code> is null
<DD><CODE>java.lang.NullPointerException</CODE> - if <code>triangles</code> is null
<DD><CODE>java.lang.NullPointerException</CODE> - if <code>appearance</code> is null
<DD><CODE>java.lang.IllegalStateException</CODE> - if this Graphics3D does not have
         a rendering target
<DD><CODE>java.lang.IllegalStateException</CODE> - if this Graphics3D does not have
         a current camera
<DD><CODE>java.lang.IllegalStateException</CODE> - if <code>vertices</code> or
         <code>triangles</code> violates the constraints defined
         in VertexBuffer or IndexBuffer</DL>
</DD>
</DL>
<HR>

<A NAME="setCamera(javax.microedition.m3g.Camera, javax.microedition.m3g.Transform)"><!-- --></A><H3>
setCamera</H3>
<PRE>
public void <B>setCamera</B>(<A HREF="../../../javax/microedition/m3g/Camera.html">Camera</A>&nbsp;camera,
                      <A HREF="../../../javax/microedition/m3g/Transform.html">Transform</A>&nbsp;transform)</PRE>
<DL>
<DD><p>Sets the Camera to use in subsequent immediate mode rendering. The
 given transformation is from the Camera's local coordinate system
 (camera space) to the world space. The transformation is copied in,
 so any further changes to it will not be reflected in this Graphics3D.
 The node transformation of the Camera is ignored. If the Camera has
 any ancestors, they are also ignored.</p>

 <p>The scope of the Camera is respected when rendering. The rendering
 enable flag of the Camera is ignored, as always.</p>
 
 <p>The given camera-to-world transformation must be invertible in
 order that the model-to-camera (or "modelview") transformation for
 each rendered object and light source can be computed.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>camera</CODE> - the Camera to bind for immediate mode rendering, or null
        to unbind the current camera<DD><CODE>transform</CODE> - the transformation from the local coordinate system of
        <code>camera</code> to world space, or null to indicate the
        identity matrix
<DT><B>Throws:</B>
<DD><CODE>java.lang.ArithmeticException</CODE> - if <code>transform</code> is not invertible</DL>
</DD>
</DL>
<HR>

<A NAME="setLight(int, javax.microedition.m3g.Light, javax.microedition.m3g.Transform)"><!-- --></A><H3>
setLight</H3>
<PRE>
public void <B>setLight</B>(int&nbsp;index,
                     <A HREF="../../../javax/microedition/m3g/Light.html">Light</A>&nbsp;light,
                     <A HREF="../../../javax/microedition/m3g/Transform.html">Transform</A>&nbsp;transform)</PRE>
<DL>
<DD><p>Binds or unbinds a Light for subsequent immediate mode rendering.
 The given transformation is from the Light's local coordinate system to
 the world space. Note that the transformation need not be invertible.
 The transformation is copied in, so any further changes to it will not
 be reflected in this Graphics3D. The node transformation of the Light
 is ignored. If the Light has any ancestors, they are also ignored.</p>

 <p>The scope and rendering enable flag of the Light are respected
 when rendering.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>index</CODE> - index of the light to set<DD><CODE>light</CODE> - the Light to set, or null to remove the light at
        <code>index</code><DD><CODE>transform</CODE> - the transformation from the local coordinate system
        of <code>light</code> to world space, or null to indicate the
        identity matrix
<DT><B>Throws:</B>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if <code>(index &lt; 0) || (index
         &gt;= N)</code> where N is the number of lights added to the
         array since it was last reset by <code>resetLights</code></DL>
</DD>
</DL>
<HR>

<A NAME="addLight(javax.microedition.m3g.Light, javax.microedition.m3g.Transform)"><!-- --></A><H3>
addLight</H3>
<PRE>
public int <B>addLight</B>(<A HREF="../../../javax/microedition/m3g/Light.html">Light</A>&nbsp;light,
                    <A HREF="../../../javax/microedition/m3g/Transform.html">Transform</A>&nbsp;transform)</PRE>
<DL>
<DD><p>Binds a Light to use in subsequent immediate mode rendering.</p>

 <p>This method is identical to <code>setLight</code>, except
 that the Light is inserted at the end of the lights array. The
 light is always inserted at the very end, regardless of whether
 there are empty (null) slots at lower indices. The index of
 the slot in which the Light is inserted is returned to the
 application.  The returned indices are guaranteed to be
 strictly increasing, until <code>render(World)</code> or
 <code>resetLights</code> is called.</p>

 <p>The index of the added Light is guaranteed to remain the same
 until the light is either removed using <code>setLight</code>, or
 the lights array is overwritten by <code>render(World)</code>, or
 the array is explicitly cleared with <code>resetLights</code>.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>light</CODE> - the Light to add at the end of the array of current lights<DD><CODE>transform</CODE> - the transformation from the local coordinate system
        of <code>light</code> to world space, or null to indicate the
        identity matrix
<DT><B>Returns:</B><DD>the index at which the Light was inserted in the array
<DT><B>Throws:</B>
<DD><CODE>java.lang.NullPointerException</CODE> - if <code>light</code> is null</DL>
</DD>
</DL>
<HR>

<A NAME="resetLights()"><!-- --></A><H3>
resetLights</H3>
<PRE>
public void <B>resetLights</B>()</PRE>
<DL>
<DD><p>Clears the array of current Lights.</p>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getProperties()"><!-- --></A><H3>
getProperties</H3>
<PRE>
public static final java.util.Hashtable <B>getProperties</B>()</PRE>
<DL>
<DD><p>Retrieves implementation specific properties. The properties
 are stored in a Hashtable that is keyed by String values. The
 Hashtable will always contain the entries listed in the table
 below, but there may also be other entries specific to each
 implementation.</p>

 <p>The third column shows for each property the baseline
 requirement that all implementations must satisfy. The actual
 value returned may be equal to or greater than the baseline
 requirement.</p>

 <blockquote>
 <table border cellpadding=3>
 <tr>
 <th>Key (String)</th>
 <th>Value type</th>
 <th>Minimum requirement</th>
 <th>Description</th>
 </tr>
 <tr>
 <td>supportAntialiasing</td>
 <td>Boolean</td>
 <td>false</td>
 <td>See <a href="#hints">above</a></td>
 </tr>
 <tr>
 <td>supportTrueColor</td>
 <td>Boolean</td>
 <td>false</td>
 <td>See <a href="#hints">above</a></td>
 </tr>
 <tr><td>supportDithering</td>
 <td>Boolean</td>
 <td>false</td>
 <td>See <a href="#hints">above</a></td>
 </tr>
 <tr>
 <td>supportMipmapping</td>
 <td>Boolean</td>
 <td>false</td>
 <td>See <a href="Texture2D.html#filtering">Texture2D</a></td>
 </tr>
 <tr>
 <td>supportPerspectiveCorrection</td>
 <td>Boolean</td>
 <td>false</td>
 <td>See <A HREF="../../../javax/microedition/m3g/PolygonMode.html">PolygonMode</A></td>
 </tr>
 <tr>
 <td>supportLocalCameraLighting</td>
 <td>Boolean</td>
 <td>false</td>
 <td>See <A HREF="../../../javax/microedition/m3g/PolygonMode.html">PolygonMode</A></td>
 </tr>
 <tr>
 <td>maxLights</td>
 <td>Integer</td>
 <td>8</td>
 <td>See <A HREF="../../../javax/microedition/m3g/Light.html">Light</A></td>
 </tr>
 <tr>
 <td>maxViewportDimension</td>
 <td>Integer</td>
 <td>256</td>
 <td>See <A HREF="../../../javax/microedition/m3g/Graphics3D.html#setViewport(int, int, int, int)">setViewport</A></td>
 </tr>
 <tr>
 <td>maxTextureDimension</td>
 <td>Integer</td>
 <td>256</td>
 <td>See <A HREF="../../../javax/microedition/m3g/Texture2D.html">Texture2D</A></td>
 </tr>
 <tr>
 <td>maxSpriteCropDimension</td>
 <td>Integer</td>
 <td>256</td>
 <td>See <A HREF="../../../javax/microedition/m3g/Sprite3D.html">Sprite3D</A></td>
 </tr>
 <tr>
 <td>maxTransformsPerVertex</td>
 <td>Integer</td>
 <td>2</td>
 <td>See <A HREF="../../../javax/microedition/m3g/SkinnedMesh.html#addTransform(javax.microedition.m3g.Node, int, int, int)">SkinnedMesh</A></td>
 </tr>
 <tr>
 <td>numTextureUnits</td>
 <td>Integer</td>
 <td>1</td>
 <td>See <A HREF="../../../javax/microedition/m3g/Appearance.html">Appearance</A></td>
 </tr>
 </table>
 </blockquote>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>a Hashtable defining properties specific to this implementation</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>

<!-- ========== START OF NAVBAR ========== -->
<A NAME="navbar_bottom"><!-- --></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Graphics3D.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<EM><B>Nov 19, 2003</B></EM></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../javax/microedition/m3g/Fog.html"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../javax/microedition/m3g/Group.html"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html" TARGET="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Graphics3D.html" TARGET="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;
<SCRIPT>
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html" TARGET=""><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
<A HREF="../../../allclasses-noframe.html" TARGET=""><B>All Classes</B></A>
</NOSCRIPT>
</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<!-- =========== END OF NAVBAR =========== -->

<HR>
<EM>Copyright &copy 2003 Nokia Corporation. See the <a href="../../../overview-summary.html#Copyright">Copyright Notice</a> for details.</EM>
</BODY>
</HTML>
