<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN""http://www.w3.org/TR/REC-html40/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc on Thu Nov 27 13:54:34 EET 2003 -->
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<TITLE>
Group (Mobile 3D Graphics API (M3G))
</TITLE>
<META NAME="keywords" CONTENT="javax.microedition.m3g.Group,Group class">
<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">
</HEAD>
<SCRIPT>
function asd()
{
parent.document.title="Group (Mobile 3D Graphics API (M3G))";
}
</SCRIPT>
<BODY BGCOLOR="white" onload="asd();">

<!-- ========== START OF NAVBAR ========== -->
<A NAME="navbar_top"><!-- --></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Group.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<EM><B>Nov 19, 2003</B></EM></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../javax/microedition/m3g/Graphics3D.html"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../javax/microedition/m3g/Image2D.html"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html" TARGET="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Group.html" TARGET="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;
<SCRIPT>
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html" TARGET=""><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
<A HREF="../../../allclasses-noframe.html" TARGET=""><B>All Classes</B></A>
</NOSCRIPT>
</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#fields_inherited_from_class_javax.microedition.m3g.Node">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<!-- =========== END OF NAVBAR =========== -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
javax.microedition.m3g</FONT>
<BR>
Class Group</H2>
<PRE>
java.lang.Object
  |
  +--<A HREF="../../../javax/microedition/m3g/Object3D.html">javax.microedition.m3g.Object3D</A>
        |
        +--<A HREF="../../../javax/microedition/m3g/Transformable.html">javax.microedition.m3g.Transformable</A>
              |
              +--<A HREF="../../../javax/microedition/m3g/Node.html">javax.microedition.m3g.Node</A>
                    |
                    +--<B>javax.microedition.m3g.Group</B>
</PRE>
<DL>
<DT><B>Direct Known Subclasses:</B> <DD><A HREF="../../../javax/microedition/m3g/World.html">World</A></DD>
</DL>
<HR>
<DL>
<DT>public class <B>Group</B><DT>extends <A HREF="../../../javax/microedition/m3g/Node.html">Node</A></DL>

<P>
<p>A scene graph node that stores an unordered set of nodes as its
children.</p>

<p>The parent-child relationship is bidirectional in the sense that if node A
is a child of node B, then B is the (one and only) parent of A. In particular,
the <code>getParent</code> method of A will return B. Besides Group nodes, this
also concerns SkinnedMesh nodes: the skeleton group is the one and only child
of a SkinnedMesh.</p>

<p>A node can have at most one parent at a time, and cycles are prohibited.
Furthermore, a World node cannot be a child of any node. These rules are
enforced by the <code>addChild</code> method in this class, as well as the
constructor of SkinnedMesh.</p>
<P>

<P>
<DL>
<DT><B>See Also:</B><DD><a href="../../../file-format.html#Group">Binary format</a></DL>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->


<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Field Summary</B></FONT></TD>
</TR>
</TABLE>
&nbsp;<A NAME="fields_inherited_from_class_javax.microedition.m3g.Node"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Fields inherited from class javax.microedition.m3g.<A HREF="../../../javax/microedition/m3g/Node.html">Node</A></B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../javax/microedition/m3g/Node.html#NONE">NONE</A>, <A HREF="../../../javax/microedition/m3g/Node.html#ORIGIN">ORIGIN</A>, <A HREF="../../../javax/microedition/m3g/Node.html#X_AXIS">X_AXIS</A>, <A HREF="../../../javax/microedition/m3g/Node.html#Y_AXIS">Y_AXIS</A>, <A HREF="../../../javax/microedition/m3g/Node.html#Z_AXIS">Z_AXIS</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Group.html#Group()">Group</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructs a new Group node and initializes it with an empty
 list of children. </TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Method Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Group.html#addChild(javax.microedition.m3g.Node)">addChild</A></B>(<A HREF="../../../javax/microedition/m3g/Node.html">Node</A>&nbsp;child)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds the given node to this Group, potentially changing the order and
 indices of the previously added children. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../javax/microedition/m3g/Node.html">Node</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Group.html#getChild(int)">getChild</A></B>(int&nbsp;index)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets a child by index. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Group.html#getChildCount()">getChildCount</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the number of children in this Group.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Group.html#pick(int, float, float, javax.microedition.m3g.Camera, javax.microedition.m3g.RayIntersection)">pick</A></B>(int&nbsp;scope,
     float&nbsp;x,
     float&nbsp;y,
     <A HREF="../../../javax/microedition/m3g/Camera.html">Camera</A>&nbsp;camera,
     <A HREF="../../../javax/microedition/m3g/RayIntersection.html">RayIntersection</A>&nbsp;ri)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Picks the first Mesh or scaled Sprite3D in this Group that
 is enabled for picking, is intercepted by the given pick ray,
 and is in the specified <a href="Node.html#Scoping">scope</a>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Group.html#pick(int, float, float, float, float, float, float, javax.microedition.m3g.RayIntersection)">pick</A></B>(int&nbsp;scope,
     float&nbsp;ox,
     float&nbsp;oy,
     float&nbsp;oz,
     float&nbsp;dx,
     float&nbsp;dy,
     float&nbsp;dz,
     <A HREF="../../../javax/microedition/m3g/RayIntersection.html">RayIntersection</A>&nbsp;ri)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Picks the first Mesh in this Group that is intercepted by
 the given pick ray and is in the specified <a href=
 "Node.html#Scoping">scope</a>. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Group.html#removeChild(javax.microedition.m3g.Node)">removeChild</A></B>(<A HREF="../../../javax/microedition/m3g/Node.html">Node</A>&nbsp;child)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Removes the given node from this Group, potentially changing the
 order and indices of the remaining children. </TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_javax.microedition.m3g.Node"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Methods inherited from class javax.microedition.m3g.<A HREF="../../../javax/microedition/m3g/Node.html">Node</A></B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../javax/microedition/m3g/Node.html#align(javax.microedition.m3g.Node)">align</A>, <A HREF="../../../javax/microedition/m3g/Node.html#getAlphaFactor()">getAlphaFactor</A>, <A HREF="../../../javax/microedition/m3g/Node.html#getParent()">getParent</A>, <A HREF="../../../javax/microedition/m3g/Node.html#getScope()">getScope</A>, <A HREF="../../../javax/microedition/m3g/Node.html#getTransformTo(javax.microedition.m3g.Node, javax.microedition.m3g.Transform)">getTransformTo</A>, <A HREF="../../../javax/microedition/m3g/Node.html#isPickingEnabled()">isPickingEnabled</A>, <A HREF="../../../javax/microedition/m3g/Node.html#isRenderingEnabled()">isRenderingEnabled</A>, <A HREF="../../../javax/microedition/m3g/Node.html#setAlignment(javax.microedition.m3g.Node, int, javax.microedition.m3g.Node, int)">setAlignment</A>, <A HREF="../../../javax/microedition/m3g/Node.html#setAlphaFactor(float)">setAlphaFactor</A>, <A HREF="../../../javax/microedition/m3g/Node.html#setPickingEnable(boolean)">setPickingEnable</A>, <A HREF="../../../javax/microedition/m3g/Node.html#setRenderingEnable(boolean)">setRenderingEnable</A>, <A HREF="../../../javax/microedition/m3g/Node.html#setScope(int)">setScope</A></CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_javax.microedition.m3g.Transformable"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Methods inherited from class javax.microedition.m3g.<A HREF="../../../javax/microedition/m3g/Transformable.html">Transformable</A></B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../javax/microedition/m3g/Transformable.html#getCompositeTransform(javax.microedition.m3g.Transform)">getCompositeTransform</A>, <A HREF="../../../javax/microedition/m3g/Transformable.html#getOrientation(float[])">getOrientation</A>, <A HREF="../../../javax/microedition/m3g/Transformable.html#getScale(float[])">getScale</A>, <A HREF="../../../javax/microedition/m3g/Transformable.html#getTransform(javax.microedition.m3g.Transform)">getTransform</A>, <A HREF="../../../javax/microedition/m3g/Transformable.html#getTranslation(float[])">getTranslation</A>, <A HREF="../../../javax/microedition/m3g/Transformable.html#postRotate(float, float, float, float)">postRotate</A>, <A HREF="../../../javax/microedition/m3g/Transformable.html#preRotate(float, float, float, float)">preRotate</A>, <A HREF="../../../javax/microedition/m3g/Transformable.html#scale(float, float, float)">scale</A>, <A HREF="../../../javax/microedition/m3g/Transformable.html#setOrientation(float, float, float, float)">setOrientation</A>, <A HREF="../../../javax/microedition/m3g/Transformable.html#setScale(float, float, float)">setScale</A>, <A HREF="../../../javax/microedition/m3g/Transformable.html#setTransform(javax.microedition.m3g.Transform)">setTransform</A>, <A HREF="../../../javax/microedition/m3g/Transformable.html#setTranslation(float, float, float)">setTranslation</A>, <A HREF="../../../javax/microedition/m3g/Transformable.html#translate(float, float, float)">translate</A></CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_javax.microedition.m3g.Object3D"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Methods inherited from class javax.microedition.m3g.<A HREF="../../../javax/microedition/m3g/Object3D.html">Object3D</A></B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../javax/microedition/m3g/Object3D.html#addAnimationTrack(javax.microedition.m3g.AnimationTrack)">addAnimationTrack</A>, <A HREF="../../../javax/microedition/m3g/Object3D.html#animate(int)">animate</A>, <A HREF="../../../javax/microedition/m3g/Object3D.html#duplicate()">duplicate</A>, <A HREF="../../../javax/microedition/m3g/Object3D.html#find(int)">find</A>, <A HREF="../../../javax/microedition/m3g/Object3D.html#getAnimationTrack(int)">getAnimationTrack</A>, <A HREF="../../../javax/microedition/m3g/Object3D.html#getAnimationTrackCount()">getAnimationTrackCount</A>, <A HREF="../../../javax/microedition/m3g/Object3D.html#getReferences(javax.microedition.m3g.Object3D[])">getReferences</A>, <A HREF="../../../javax/microedition/m3g/Object3D.html#getUserID()">getUserID</A>, <A HREF="../../../javax/microedition/m3g/Object3D.html#getUserObject()">getUserObject</A>, <A HREF="../../../javax/microedition/m3g/Object3D.html#removeAnimationTrack(javax.microedition.m3g.AnimationTrack)">removeAnimationTrack</A>, <A HREF="../../../javax/microedition/m3g/Object3D.html#setUserID(int)">setUserID</A>, <A HREF="../../../javax/microedition/m3g/Object3D.html#setUserObject(java.lang.Object)">setUserObject</A></CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Methods inherited from class java.lang.Object</B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>equals, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->


<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="Group()"><!-- --></A><H3>
Group</H3>
<PRE>
public <B>Group</B>()</PRE>
<DL>
<DD><p>Constructs a new Group node and initializes it with an empty
 list of children. Properties inherited from Object3D and Node
 will have the default values as specified in their respective
 class descriptions.</p>
<P>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Method Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="addChild(javax.microedition.m3g.Node)"><!-- --></A><H3>
addChild</H3>
<PRE>
public void <B>addChild</B>(<A HREF="../../../javax/microedition/m3g/Node.html">Node</A>&nbsp;child)</PRE>
<DL>
<DD><p>Adds the given node to this Group, potentially changing the order and
 indices of the previously added children. The position at which the node
 is inserted among the existing children is deliberately left undefined.
 This gives implementations the freedom to select a data structure that
 best fits their needs, instead of mandating a particular kind of data
 structure.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>child</CODE> - the node to add; must not form a loop in the scene graph
<DT><B>Throws:</B>
<DD><CODE>java.lang.NullPointerException</CODE> - if <code>child</code> is null
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>child</code> is this Group
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>child</code> is a World node
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>child</code> already has a
         parent
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>child</code> is an ancestor
         of this Group</DL>
</DD>
</DL>
<HR>

<A NAME="removeChild(javax.microedition.m3g.Node)"><!-- --></A><H3>
removeChild</H3>
<PRE>
public void <B>removeChild</B>(<A HREF="../../../javax/microedition/m3g/Node.html">Node</A>&nbsp;child)</PRE>
<DL>
<DD><p>Removes the given node from this Group, potentially changing the
 order and indices of the remaining children. If the given node is
 not a child of this Group, or is null, the request to remove it is
 silently ignored.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>child</CODE> - the node to remove
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if removing <code>child</code>
 would break a connection between a SkinnedMesh node and one of
 its transform references</DL>
</DD>
</DL>
<HR>

<A NAME="getChildCount()"><!-- --></A><H3>
getChildCount</H3>
<PRE>
public int <B>getChildCount</B>()</PRE>
<DL>
<DD><p>Gets the number of children in this Group.</p>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the number of children directly attached to this group</DL>
</DD>
</DL>
<HR>

<A NAME="getChild(int)"><!-- --></A><H3>
getChild</H3>
<PRE>
public <A HREF="../../../javax/microedition/m3g/Node.html">Node</A> <B>getChild</B>(int&nbsp;index)</PRE>
<DL>
<DD><p>Gets a child by index. Valid indices range from zero up to
 the number of children minus one. Note that the index of any
 child may change whenever a node is added to or removed from
 this Group. See <code>addChild</code> for more information.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>index</CODE> - index of the child node to get
<DT><B>Returns:</B><DD>the child node at the given index; can not be null
<DT><B>Throws:</B>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if <code>(index &lt; 0) ||
         (index &gt;= getChildCount)</code></DL>
</DD>
</DL>
<HR>

<A NAME="pick(int, float, float, float, float, float, float, javax.microedition.m3g.RayIntersection)"><!-- --></A><H3>
pick</H3>
<PRE>
public boolean <B>pick</B>(int&nbsp;scope,
                    float&nbsp;ox,
                    float&nbsp;oy,
                    float&nbsp;oz,
                    float&nbsp;dx,
                    float&nbsp;dy,
                    float&nbsp;dz,
                    <A HREF="../../../javax/microedition/m3g/RayIntersection.html">RayIntersection</A>&nbsp;ri)</PRE>
<DL>
<DD><p>Picks the first Mesh in this Group that is intercepted by
 the given pick ray and is in the specified <a href=
 "Node.html#Scoping">scope</a>. Meshes that are <A HREF="../../../javax/microedition/m3g/Node.html#setPickingEnable(boolean)">disabled</A> or out of scope are ignored.
 Any ancestors of this Group, including their picking enable
 flags, are ignored. Winding and culling flags for each Mesh are
 respected when determining a hit, such that triangles culled
 based on their facing with respect to the pick ray are
 ignored.</p>

 <p>The pick ray is cast in the given direction from the given
 location in the coordinate system of this Group. The direction
 vector of the ray does not need to be unit length; the distance
 to the picked object is computed relative to the length of the
 given ray.</p>

 <p>Information about the picked object, if any, is filled in to
 the given RayIntersection object. If no intersection occurs, the
 RayIntersection object is left unmodified.</p>

 <p>This method ignores all Sprite3D nodes. This is because the
 camera parameters (that is, the projection matrix) are required
 in order to compute the size of a sprite (see the Sprite3D class
 description), and that information is not available to this
 method. Developers are advised to use the other <code>pick</code>
 variant if picking of sprites is desired.</p>
 
 <p>The application should ensure that there are no uninvertible
 node transformations in this Group. Depending on how picking is
 implemented, singular transformations may or may not trigger an
 ArithmeticException.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>scope</CODE> - an integer scope specifying which Meshes to test
        for intersection with the pick ray; "-1" makes the scope
        as wide as possible<DD><CODE>ox</CODE> - X coordinate of the ray origin<DD><CODE>oy</CODE> - Y coordinate of the ray origin<DD><CODE>oz</CODE> - Z coordinate of the ray origin<DD><CODE>dx</CODE> - X component of the ray direction<DD><CODE>dy</CODE> - Y component of the ray direction<DD><CODE>dz</CODE> - Z component of the ray direction<DD><CODE>ri</CODE> - a RayIntersection object to fill in with information
        about the intersected Mesh, or null to just find out
        whether the ray intersected something or not
<DT><B>Returns:</B><DD><i>true</i> if the ray intersected a Mesh;
         <i>false</i> otherwise
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>dx = dy = dz = 0</code>
<DD><CODE>java.lang.IllegalStateException</CODE> - if any Mesh that is tested for
         intersection violates the constraints defined in Mesh,
         MorphingMesh, SkinnedMesh, VertexBuffer, or IndexBuffer
<DD><CODE>java.lang.ArithmeticException</CODE> - if the inverse of an uninvertible
         transformation is required by the implementation</DL>
</DD>
</DL>
<HR>

<A NAME="pick(int, float, float, javax.microedition.m3g.Camera, javax.microedition.m3g.RayIntersection)"><!-- --></A><H3>
pick</H3>
<PRE>
public boolean <B>pick</B>(int&nbsp;scope,
                    float&nbsp;x,
                    float&nbsp;y,
                    <A HREF="../../../javax/microedition/m3g/Camera.html">Camera</A>&nbsp;camera,
                    <A HREF="../../../javax/microedition/m3g/RayIntersection.html">RayIntersection</A>&nbsp;ri)</PRE>
<DL>
<DD><p>Picks the first Mesh or scaled Sprite3D in this Group that
 is enabled for picking, is intercepted by the given pick ray,
 and is in the specified <a href="Node.html#Scoping">scope</a>.</p>

 <p>This method behaves identically to the other <code>pick</code>
 variant, except that the pick ray is specified differently and
 that scaled sprites can also be picked. Unscaled sprites can not
 be picked. This is because the size of an unscaled sprite is only
 defined in screen space (that is, after viewport transformation),
 and the viewport parameters are not available to this method. See
 the Sprite3D class description for more information on sprite
 picking.</p>
 
 <p>The pick ray is cast from the given point <b>p</b> = (x, y)
 on the near clipping plane towards the corresponding point on
 the far clipping plane, and then beyond. See the Implementation
 guidelines below for details.</p>

 <p>Note that the origin of the pick ray is <i>not</i> the given
 Camera, but the point on the near clipping plane. Consequently
 the distance to the picked object, returned in RayIntersection,
 is not the distance from the camera, but the distance from the
 point <b>p</b>.</p>
 
 <p>The point <b>p</b> is specified relative to the viewport
 such that (0, 0) is the upper left corner and (1, 1) is the
 lower right corner. However, the (x, y) coordinates are not
 restricted to that range and may take on any values. In other
 words, objects that do not lie within the viewport can also be
 picked.</p>
 
 <p>The given Camera and this Group must be in the same scene
 graph, that is, they must have at least one common ancestor.
 Furthermore, the projection matrix of the Camera must be
 invertible. Depending on how picking is implemented, objects
 within the Group which have uninvertible modelview matrices
 may or may not trigger an ArithmeticException.</p>

 <h3>Implementation guidelines</h3>
 
 <p>The pick ray is cast towards infinity from the given point
 <b>p</b> on the near clipping plane, through a point <b>p</b>'
 on the far clipping plane. The exact procedure of deriving the
 pick ray origin and direction from the given point (x, y) and
 the given projection matrix <b>P</b> is as follows.</p>
 
 <p>In normalized device coordinates (NDC), the viewport spans
 the range [-1, 1] in each dimension (X, Y and Z). Points that
 lie on the near plane have a Z coordinate of -1 in NDC; points
 on the far plane have a Z of 1. The normalized device coordinates
 of <b>p</b> and <b>p</b>' are, therefore:</p>
 
 <blockquote>
 <b>p</b><sub>ndc</sub> = (2x-1, 1-2y, -1, 1)<sup>T</sup><br>
 <b>p</b>'<sub>ndc</sub> = (2x-1, 1-2y, 1, 1)<sup>T</sup>
 </blockquote>

 <p>Note that the Y coordinate is inverted when going from NDC
 to viewport or vice versa, as the viewport upper left corner
 maps to (-1, 1) in NDC (see also the viewport transformation
 equation in <code>Graphics3D.setViewport</code>). Applying the
 inverse projection matrix on the pick points, we obtain their
 positions in camera space:</p>

 <blockquote>
 <b>p</b><sub>c</sub> = <b>P</b><sup>-1</sup> <b>p</b><sub>ndc</sub><br>
 <b>p</b>'<sub>c</sub> = <b>P</b><sup>-1</sup> <b>p</b>'<sub>ndc</sub>
 </blockquote>

 <p>We then scale the resultant homogeneous points such that their
 W components are equal to 1; that might not otherwise be the case
 after the inverse projection. Formally, denoting the W components
 of the near and far points by w and w', the final camera space
 coordinates are obtained as follows:</p>
 
 <blockquote>
 <b>p</b> = <b>p</b><sub>c</sub> / w<br>
 <b>p'</b> = <b>p</b>'<sub>c</sub> / w'
 </blockquote>

 <p>The origin of the pick ray in camera coordinates is then
 <b>p</b> while its direction vector is <b>p</b>' - <b>p</b>.</p>
 
 <p>Finally, the pick ray is transformed from camera space to the
 coordinate system of this Group. That ray is used in the actual
 intersection tests, and is also the one that is returned by the
 <code>getRay</code> method in RayIntersection.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>scope</CODE> - an integer scope specifying which meshes and sprites
        to test for intersection with the pick ray; -1 makes the
        scope as wide as possible<DD><CODE>x</CODE> - X coordinate of the point on the viewport plane through
        which to cast the ray<DD><CODE>y</CODE> - Y coordinate of the point on the viewport plane through
        which to cast the ray<DD><CODE>camera</CODE> - a camera based on which the origin and direction of
        the pick ray are to be computed<DD><CODE>ri</CODE> - a RayIntersection object to fill in with information
        about the intersected Mesh, or null to just find out
        whether the ray intersected something or not
<DT><B>Returns:</B><DD><i>true</i> if the ray intersected a Mesh or Sprite3D;
         <i>false</i> otherwise
<DT><B>Throws:</B>
<DD><CODE>java.lang.NullPointerException</CODE> - if <code>camera</code> is null
<DD><CODE>java.lang.IllegalStateException</CODE> - if any Mesh that is tested for
         intersection violates the constraints defined in Mesh,
         MorphingMesh, SkinnedMesh, VertexBuffer, or IndexBuffer
<DD><CODE>java.lang.IllegalStateException</CODE> - if there is no scene graph path
         between <code>camera</code> and this Group
<DD><CODE>java.lang.ArithmeticException</CODE> - if the inverse of an uninvertible
         transformation is required by the implementation</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>

<!-- ========== START OF NAVBAR ========== -->
<A NAME="navbar_bottom"><!-- --></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Group.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<EM><B>Nov 19, 2003</B></EM></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../javax/microedition/m3g/Graphics3D.html"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../javax/microedition/m3g/Image2D.html"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html" TARGET="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Group.html" TARGET="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;
<SCRIPT>
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html" TARGET=""><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
<A HREF="../../../allclasses-noframe.html" TARGET=""><B>All Classes</B></A>
</NOSCRIPT>
</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#fields_inherited_from_class_javax.microedition.m3g.Node">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<!-- =========== END OF NAVBAR =========== -->

<HR>
<EM>Copyright &copy 2003 Nokia Corporation. See the <a href="../../../overview-summary.html#Copyright">Copyright Notice</a> for details.</EM>
</BODY>
</HTML>
