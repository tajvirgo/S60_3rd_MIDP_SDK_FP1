<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN""http://www.w3.org/TR/REC-html40/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc on Thu Nov 27 13:54:35 EET 2003 -->
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<TITLE>
Node (Mobile 3D Graphics API (M3G))
</TITLE>
<META NAME="keywords" CONTENT="javax.microedition.m3g.Node,Node class">
<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">
</HEAD>
<SCRIPT>
function asd()
{
parent.document.title="Node (Mobile 3D Graphics API (M3G))";
}
</SCRIPT>
<BODY BGCOLOR="white" onload="asd();">

<!-- ========== START OF NAVBAR ========== -->
<A NAME="navbar_top"><!-- --></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Node.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<EM><B>Nov 19, 2003</B></EM></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../javax/microedition/m3g/MorphingMesh.html"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../javax/microedition/m3g/Object3D.html"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html" TARGET="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Node.html" TARGET="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;
<SCRIPT>
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html" TARGET=""><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
<A HREF="../../../allclasses-noframe.html" TARGET=""><B>All Classes</B></A>
</NOSCRIPT>
</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<!-- =========== END OF NAVBAR =========== -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
javax.microedition.m3g</FONT>
<BR>
Class Node</H2>
<PRE>
java.lang.Object
  |
  +--<A HREF="../../../javax/microedition/m3g/Object3D.html">javax.microedition.m3g.Object3D</A>
        |
        +--<A HREF="../../../javax/microedition/m3g/Transformable.html">javax.microedition.m3g.Transformable</A>
              |
              +--<B>javax.microedition.m3g.Node</B>
</PRE>
<DL>
<DT><B>Direct Known Subclasses:</B> <DD><A HREF="../../../javax/microedition/m3g/Camera.html">Camera</A>, <A HREF="../../../javax/microedition/m3g/Group.html">Group</A>, <A HREF="../../../javax/microedition/m3g/Light.html">Light</A>, <A HREF="../../../javax/microedition/m3g/Mesh.html">Mesh</A>, <A HREF="../../../javax/microedition/m3g/Sprite3D.html">Sprite3D</A></DD>
</DL>
<HR>
<DL>
<DT>public abstract class <B>Node</B><DT>extends <A HREF="../../../javax/microedition/m3g/Transformable.html">Transformable</A></DL>

<P>
<p>An abstract base class for all scene graph nodes.</p>

<p>There are five different kinds of nodes:</p>

<ul>
<li><A HREF="../../../javax/microedition/m3g/Camera.html"><CODE>Camera</CODE></A> defines the projection from 3D to 2D, as well as
    the position of the viewer in the scene.</li>
<li><A HREF="../../../javax/microedition/m3g/Mesh.html"><CODE>Mesh</CODE></A> defines a 3D object, consisting of triangles with
    associated material properties.</li>
<li><A HREF="../../../javax/microedition/m3g/Sprite3D.html"><CODE>Sprite3D</CODE></A> defines a screen-aligned 2D image with a position
    in 3D space.</li>
<li><A HREF="../../../javax/microedition/m3g/Light.html"><CODE>Light</CODE></A> defines the position, direction, color and other
    attributes of a light source.</li>
<li><A HREF="../../../javax/microedition/m3g/Group.html"><CODE>Group</CODE></A> serves as a root for scene graph branches.</li>
</ul>

<h3>Node transformation</h3>

<p>Each node defines a local coordinate system that can be transformed
relative to the coordinate system of the parent node. The transformation
<i>from</i> the local coordinate system of a node <i>to</i> the coordinate
system of its parent is called the <i>node transformation</i>.</p>

<p>The node transformation consists of four parts: a generic matrix
<b>M</b>, a non-uniform scale <b>S</b>, an orientation <b>R</b> and a
translation <b>T</b>. The bottom row of <b>M</b> must be equal to (0 0
0 1). The methods to manipulate the individual components are defined
in the base class, <A HREF="../../../javax/microedition/m3g/Transformable.html">Transformable</A>.</p>

<p>To transform a point from a node's local coordinates to its
parent's coordinates, the point is multiplied by the transformation
components in the order that they are listed above. Formally, a
homogeneous vector <b>p</b> = (x, y, z, 1), representing a 3D point in
the local coordinate system, is transformed into <b>p</b>' = (x', y',
z', 1) in the parent coordinate system as follows:</p>

<blockquote>
<b>p</b>' = <b>T</b> <b>R</b> <b>S</b> <b>M</b> <b>p</b>
</blockquote>

<p>The translation, orientation and scale components of the node
transformation can be animated independently from each other. The
matrix component is not animatable at all; it can only be changed
using the <code>setTransform</code> method.</p>

<h3>Node alignment</h3>

<p>A node may be <i>aligned</i> with respect to a selected <i>reference
node</i> (or nodes). This means that the aligned node is, upon request,
automatically oriented so that its coordinate system matches the reference
node's coordinate system in the specified way. A common use case for node
alignment is to create "billboards" that are always facing the camera;
another is to make the camera always point at a certain object.</p>

<p>When a node is aligned, its original orientation component <b>R</b> is
overwritten with an aligned orientation <b>A</b>. (The aligned orientation
is computed as specified below, in the Implementation Guidelines section.)
The other components of the node transformation are not affected by
alignment. The transformation from the local coordinate system of an
aligned node to its parent node's coordinate system is, therefore,</p>

<blockquote>
<b>p</b>' = <b>T</b> <b>A</b> <b>S</b> <b>M</b> <b>p</b>
</blockquote>

<p>The application must explicitly call the <code>align</code> method on
a node (or any of its ancestors) when it requires the alignments of that
node and its descendants to be computed. This is typically done once per
frame, before rendering. Rendering operations do not resolve any alignments;
they simply use whatever orientation each node has at that time. The same
holds true for <code>getTransformTo</code> and any other methods whose
results depend on the orientation.</p>

<p>The alignment reference node(s) and the method of alignment are selected
with <code>setAlignment</code>. This does not yet compute the new aligned
orientation, but merely specifies how that is to be done. Optionally, the
reference node may be left unspecified (null) until when <code>align</code>
is called; the reference node is then supplied as a parameter to
<code>align</code>. This is very useful for billboards, because otherwise
the application would have to call <code>setAlignment</code> separately for
every billboard in the scene whenever the camera is changed.</p>

<h3>Inherited node properties</h3>

<p>Besides the node transformation, there are three node properties
whose effective values are in some manner influenced by the ancestors
of each node. These properties are the alpha factor, the rendering enable
flag, and the picking enable flag.</p>

<p>The <i>alpha factor</i> allows (groups of) Mesh objects to be faded
in and out in a convenient way, provided that certain preconditions
related to their Appearance are met. The alpha factor is defined for
each Node, and its value is between [0, 1]. The effective alpha factor
for a Mesh is obtained by multiplying its local alpha factor with the
alpha factors of its ancestors.</p>

<p>When rendering a Mesh, its effective alpha factor is multiplied
with the alpha component of the diffuse color in each of the Material
objects associated with that Mesh. In absence of a Material object,
the alpha factor is applied to the VertexBuffer color array (if
present) or the default color. This implies, for example, that the
alpha factor has no effect on submeshes using the <code>REPLACE</code>
texture blending mode. The alpha factor is also ignored for Light,
Sprite3D and Camera nodes.</p>

<p>The <i>enable flags</i> for rendering and picking allow (groups of)
mesh and sprite objects to be made "invisible" from the point of view
of rendering and picking, respectively. The effective enable status of
a node is the logical AND of the enable flags on that node and all its
ancestors. Therefore, setting the enable flag of a node to <i>true</i>
does not guarantee that the node will be rendered or picked. Rather, if
any of its ancestors are disabled, the node will be ignored regardless
of its own enable flag.</p>

<p>Note that the scope of a Node is <i>not</i> an inherited property;
see below for more information.</p>

<h3><a name="Scoping">Scoping</a></h3>

<p>The <i>scope</i> of a Node is an integer bitmask that allows scene graph
nodes to form conceptual groups independent of the scene graph hierarchy. In
other words, nodes that are in a particular Group are not necessarily in the
same scope. Formally, two nodes A and B are defined to be in the same scope
if the bitwise AND of their scopes is non-zero:</p>

<blockquote>
scope<sub>A</sub> &amp; scope<sub>B</sub> != 0
</blockquote>

<p>Scopes are not hierarchic in any way. In particular, the scope of
a Group or SkinnedMesh node is not propagated to or inherited by its
children. After all, scopes are intended to be separate from the scene
hierarchy.</p>

<p>Scoping serves three purposes:</p>

<ul>
<p><li><b>Visibility culling</b>. Only those objects are rendered
that are in the same scope as the Camera. This gives an additional
means to control the set of visible objects, complementary to the
rendering enable flag.</li></p>

<p><li><b>Lighting</b>. A light source only has an effect on Meshes that are
in the same scope with it. This makes it possible to have a very large
number of light sources in a scene graph without having all the lights
illuminate all meshes. Besides being impractical, that would also be
prohibitively expensive in terms of processing power.</li></p>

<p><li><b>Picking.</b> The scope of the pick ray is given as a parameter to
the <code>pick</code> methods in Group. Again, only those objects can be
picked that are in the same scope as the pick ray; the others are
ignored.</li></p>
</ul>

<p>The default scope is -1, implying that all nodes are in the same scope.
By default, all objects are therefore visible to all cameras, and are lit
by all light sources.</p>

<h3><a name="Instantiation">Instantiation</a></h3>

<p>Node is an abstract class, and therefore has no public constructor.
When a class derived from Node is instantiated, the attributes defined
in Node will have the following default values:</p>

<ul>
<li>parent node : null</li>
<li>rendering enable : <i>true</i></li>
<li>picking enable : <i>true</i></li>
<li>alpha factor : 1.0</li>
<li>alignment : none</li>
<li>scope : -1</li>
</ul>

<h3>Implementation guidelines</h3>

<p>The alignment rotation <b>A</b> is computed relative to the initial
coordinate system A defined by the <b>T</b> component of the node
transformation alone. All other transformation components of the node
being aligned are ignored.</p>

<p>Conceptually, alignment is composed of two cumulative rotations:
the shortest rotation <b>R</b><sub>z</sub> that takes the initial Z
axis to the Z alignment target vector, followed by the rotation
<b>R</b><sub>y</sub> about the resulting Z vector that minimizes the
angle between the resulting Y axis and the Y alignment target vector.
If alignment is set for one axis only, that rotation is performed like
the initial Z rotation.</p>

<p>Formally, let us denote by <b>t</b><sub>Z</sub> and
<b>t</b><sub>Y</sub> the Z and Y alignment target vectors, transformed
from their respective reference nodes to A; note that axis targets
transform as vectors, and origin targets as points. The axis for the
first rotation <b>R</b><sub>z</sub> is then the cross product of the
local Z axis of A and the target vector:</p>

<blockquote>
<b>a</b><sub>Z</sub> = (0 0 1)<sup>T</sup> &times; <b>t</b><sub>Z</sub>
</blockquote>

<p>and the rotation angle can be computed via the dot product of the
two. Rotating by <b>R</b><sub>z</sub> takes us to a new coordinate frame
B where <b>t</b><sub>Y</sub> is expressed as:</p>

<blockquote>
<b>t</b><sub>Y</sub>' = <b>R</b><sub>Z</sub><sup>-1</sup> &times;
                        <b>t</b><sub>Y</sub>
</blockquote>

<p>The axis for the second rotation <b>R</b><sub>Y</sub> is the local
Z axis of B, and the angle is the angle between the local Y axis and
the projection of <b>t</b><sub>Y</sub>' on the XY plane.  The final
alignment rotation <b>A</b> is then:</p>

<blockquote>
<b>A</b> = <b>R</b><sub>Z</sub> <b>R</b><sub>Y</sub>
</blockquote>

<p>There are two cases where a rotation axis is undefined. Firstly, if
either target vector coincides with the axis that it is a target for,
the respective rotation must be substituted with an identity rotation.
Secondly, if the target vector and the axis are opposite, the exact
rotation path (that is, the resultant direction of the other two axes)
is implementation dependent, but must be deterministic. Note that the
latter only matters for unconstrained (single-axis) alignment.</p>
<P>

<P>
<DL>
<DT><B>See Also:</B><DD><a href="../../../file-format.html#Node">Binary format</a></DL>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->


<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Field Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Node.html#NONE">NONE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specifies for the <code>setAlignment</code> method that no
 alignment should be done for the specified axis.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Node.html#ORIGIN">ORIGIN</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specifies the origin of the reference node as an orientation 
 reference for the <code>setAlignment</code> method.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Node.html#X_AXIS">X_AXIS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specifies the X axis of the reference node as an orientation
 reference for the <code>setAlignment</code> method.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Node.html#Y_AXIS">Y_AXIS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specifies the Y axis of the reference node as an orientation
 reference for the <code>setAlignment</code> method.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Node.html#Z_AXIS">Z_AXIS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specifies the Z axis of the reference node as an orientation
 reference for the <code>setAlignment</code> method.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->


<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Method Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Node.html#align(javax.microedition.m3g.Node)">align</A></B>(<A HREF="../../../javax/microedition/m3g/Node.html">Node</A>&nbsp;reference)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Applies alignments to this Node and its descendants.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Node.html#getAlphaFactor()">getAlphaFactor</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves the alpha factor of this Node. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../javax/microedition/m3g/Node.html">Node</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Node.html#getParent()">getParent</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the scene graph parent of this node.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Node.html#getScope()">getScope</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves the scope of this Node.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Node.html#getTransformTo(javax.microedition.m3g.Node, javax.microedition.m3g.Transform)">getTransformTo</A></B>(<A HREF="../../../javax/microedition/m3g/Node.html">Node</A>&nbsp;target,
               <A HREF="../../../javax/microedition/m3g/Transform.html">Transform</A>&nbsp;transform)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the composite transformation from this node to the given node.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Node.html#isPickingEnabled()">isPickingEnabled</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves the picking enable flag of this Node. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Node.html#isRenderingEnabled()">isRenderingEnabled</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves the rendering enable flag of this Node. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Node.html#setAlignment(javax.microedition.m3g.Node, int, javax.microedition.m3g.Node, int)">setAlignment</A></B>(<A HREF="../../../javax/microedition/m3g/Node.html">Node</A>&nbsp;zRef,
             int&nbsp;zTarget,
             <A HREF="../../../javax/microedition/m3g/Node.html">Node</A>&nbsp;yRef,
             int&nbsp;yTarget)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets this node to align with the given other node(s), or disables
 alignment. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Node.html#setAlphaFactor(float)">setAlphaFactor</A></B>(float&nbsp;alphaFactor)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the alpha factor for this Node. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Node.html#setPickingEnable(boolean)">setPickingEnable</A></B>(boolean&nbsp;enable)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the picking enable flag of this Node. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Node.html#setRenderingEnable(boolean)">setRenderingEnable</A></B>(boolean&nbsp;enable)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the rendering enable flag of this Node. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Node.html#setScope(int)">setScope</A></B>(int&nbsp;scope)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the scope of this node. </TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_javax.microedition.m3g.Transformable"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Methods inherited from class javax.microedition.m3g.<A HREF="../../../javax/microedition/m3g/Transformable.html">Transformable</A></B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../javax/microedition/m3g/Transformable.html#getCompositeTransform(javax.microedition.m3g.Transform)">getCompositeTransform</A>, <A HREF="../../../javax/microedition/m3g/Transformable.html#getOrientation(float[])">getOrientation</A>, <A HREF="../../../javax/microedition/m3g/Transformable.html#getScale(float[])">getScale</A>, <A HREF="../../../javax/microedition/m3g/Transformable.html#getTransform(javax.microedition.m3g.Transform)">getTransform</A>, <A HREF="../../../javax/microedition/m3g/Transformable.html#getTranslation(float[])">getTranslation</A>, <A HREF="../../../javax/microedition/m3g/Transformable.html#postRotate(float, float, float, float)">postRotate</A>, <A HREF="../../../javax/microedition/m3g/Transformable.html#preRotate(float, float, float, float)">preRotate</A>, <A HREF="../../../javax/microedition/m3g/Transformable.html#scale(float, float, float)">scale</A>, <A HREF="../../../javax/microedition/m3g/Transformable.html#setOrientation(float, float, float, float)">setOrientation</A>, <A HREF="../../../javax/microedition/m3g/Transformable.html#setScale(float, float, float)">setScale</A>, <A HREF="../../../javax/microedition/m3g/Transformable.html#setTransform(javax.microedition.m3g.Transform)">setTransform</A>, <A HREF="../../../javax/microedition/m3g/Transformable.html#setTranslation(float, float, float)">setTranslation</A>, <A HREF="../../../javax/microedition/m3g/Transformable.html#translate(float, float, float)">translate</A></CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_javax.microedition.m3g.Object3D"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Methods inherited from class javax.microedition.m3g.<A HREF="../../../javax/microedition/m3g/Object3D.html">Object3D</A></B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../javax/microedition/m3g/Object3D.html#addAnimationTrack(javax.microedition.m3g.AnimationTrack)">addAnimationTrack</A>, <A HREF="../../../javax/microedition/m3g/Object3D.html#animate(int)">animate</A>, <A HREF="../../../javax/microedition/m3g/Object3D.html#duplicate()">duplicate</A>, <A HREF="../../../javax/microedition/m3g/Object3D.html#find(int)">find</A>, <A HREF="../../../javax/microedition/m3g/Object3D.html#getAnimationTrack(int)">getAnimationTrack</A>, <A HREF="../../../javax/microedition/m3g/Object3D.html#getAnimationTrackCount()">getAnimationTrackCount</A>, <A HREF="../../../javax/microedition/m3g/Object3D.html#getReferences(javax.microedition.m3g.Object3D[])">getReferences</A>, <A HREF="../../../javax/microedition/m3g/Object3D.html#getUserID()">getUserID</A>, <A HREF="../../../javax/microedition/m3g/Object3D.html#getUserObject()">getUserObject</A>, <A HREF="../../../javax/microedition/m3g/Object3D.html#removeAnimationTrack(javax.microedition.m3g.AnimationTrack)">removeAnimationTrack</A>, <A HREF="../../../javax/microedition/m3g/Object3D.html#setUserID(int)">setUserID</A>, <A HREF="../../../javax/microedition/m3g/Object3D.html#setUserObject(java.lang.Object)">setUserObject</A></CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Methods inherited from class java.lang.Object</B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>equals, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Field Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="NONE"><!-- --></A><H3>
NONE</H3>
<PRE>
public static final int <B>NONE</B></PRE>
<DL>
<DD><p>Specifies for the <code>setAlignment</code> method that no
 alignment should be done for the specified axis.</p>
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#javax.microedition.m3g.Node.NONE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="ORIGIN"><!-- --></A><H3>
ORIGIN</H3>
<PRE>
public static final int <B>ORIGIN</B></PRE>
<DL>
<DD><p>Specifies the origin of the reference node as an orientation 
 reference for the <code>setAlignment</code> method.</p>
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#javax.microedition.m3g.Node.ORIGIN">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="X_AXIS"><!-- --></A><H3>
X_AXIS</H3>
<PRE>
public static final int <B>X_AXIS</B></PRE>
<DL>
<DD><p>Specifies the X axis of the reference node as an orientation
 reference for the <code>setAlignment</code> method.</p>
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#javax.microedition.m3g.Node.X_AXIS">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="Y_AXIS"><!-- --></A><H3>
Y_AXIS</H3>
<PRE>
public static final int <B>Y_AXIS</B></PRE>
<DL>
<DD><p>Specifies the Y axis of the reference node as an orientation
 reference for the <code>setAlignment</code> method.</p>
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#javax.microedition.m3g.Node.Y_AXIS">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="Z_AXIS"><!-- --></A><H3>
Z_AXIS</H3>
<PRE>
public static final int <B>Z_AXIS</B></PRE>
<DL>
<DD><p>Specifies the Z axis of the reference node as an orientation
 reference for the <code>setAlignment</code> method.</p>
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#javax.microedition.m3g.Node.Z_AXIS">Constant Field Values</A></DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->


<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Method Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="setRenderingEnable(boolean)"><!-- --></A><H3>
setRenderingEnable</H3>
<PRE>
public void <B>setRenderingEnable</B>(boolean&nbsp;enable)</PRE>
<DL>
<DD><p>Sets the rendering enable flag of this Node. The effective
 rendering enable status for this node is the logical AND of the
 enable flags on this node and all its ancestors. Therefore, the
 node is disabled if any of its ancestors are. The node's own
 status has an effect only if all the ancestors are enabled.</p>

 <p>If the effective status is <i>true</i>, this node is enabled
 for rendering; otherwise, it is disabled. Sprite3D, Mesh and Light
 nodes are turned on and off with this setting, but on Camera
 nodes it is ignored.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>enable</CODE> - <i>true</i> to enable rendering; <i>false</i> to disable</DL>
</DD>
</DL>
<HR>

<A NAME="setPickingEnable(boolean)"><!-- --></A><H3>
setPickingEnable</H3>
<PRE>
public void <B>setPickingEnable</B>(boolean&nbsp;enable)</PRE>
<DL>
<DD><p>Sets the picking enable flag of this Node. The effective
 picking enable status for this node is the logical AND of the
 enable flags on this node and all its ancestors. Therefore, the
 node is disabled if any of its ancestors are. The node's own
 status has an effect only if all the ancestors are enabled.</p>

 <p>If the effective status is <i>true</i>, this node is enabled
 for picking; otherwise, it is disabled. This setting is ignored
 for Lights and Cameras, because they are unpickable in any case.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>enable</CODE> - <i>true</i> to enable picking; <i>false</i> to disable</DL>
</DD>
</DL>
<HR>

<A NAME="setScope(int)"><!-- --></A><H3>
setScope</H3>
<PRE>
public void <B>setScope</B>(int&nbsp;scope)</PRE>
<DL>
<DD><p>Sets the scope of this node. The scope is used to limit the
 set of nodes that are taken into account in rendering, lighting
 and picking. See the class description for more information.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>scope</CODE> - the new scope for this node<DT><B>See Also:</B><DD><A HREF="../../../javax/microedition/m3g/Node.html#getScope()"><CODE>getScope</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setAlphaFactor(float)"><!-- --></A><H3>
setAlphaFactor</H3>
<PRE>
public void <B>setAlphaFactor</B>(float&nbsp;alphaFactor)</PRE>
<DL>
<DD><p>Sets the alpha factor for this Node. This can be used to
 fade groups of meshes in and out. The alpha factor has no
 effect on Sprite3D, Light and Camera nodes. See the class
 description for more information.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>alphaFactor</CODE> - the new alpha factor for this node; must be [0, 1]
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>alphaFactor</code> is
         negative or greater than 1.0<DT><B>See Also:</B><DD><A HREF="../../../javax/microedition/m3g/Node.html#getAlphaFactor()"><CODE>getAlphaFactor</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="isRenderingEnabled()"><!-- --></A><H3>
isRenderingEnabled</H3>
<PRE>
public boolean <B>isRenderingEnabled</B>()</PRE>
<DL>
<DD><p>Retrieves the rendering enable flag of this Node. Note that
 this is not the effective rendering enable status, but only the
 local status of this Node.</p>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the rendering enable flag of this Node<DT><B>See Also:</B><DD><A HREF="../../../javax/microedition/m3g/Node.html#setRenderingEnable(boolean)"><CODE>setRenderingEnable</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="isPickingEnabled()"><!-- --></A><H3>
isPickingEnabled</H3>
<PRE>
public boolean <B>isPickingEnabled</B>()</PRE>
<DL>
<DD><p>Retrieves the picking enable flag of this Node. Note that
 this is not the effective picking enable status, but only the
 local status of this Node.</p>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the picking enable flag of this Node<DT><B>See Also:</B><DD><A HREF="../../../javax/microedition/m3g/Node.html#setPickingEnable(boolean)"><CODE>setPickingEnable</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getScope()"><!-- --></A><H3>
getScope</H3>
<PRE>
public int <B>getScope</B>()</PRE>
<DL>
<DD><p>Retrieves the scope of this Node.</p>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the current scope of this Node<DT><B>See Also:</B><DD><A HREF="../../../javax/microedition/m3g/Node.html#setScope(int)"><CODE>setScope</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getAlphaFactor()"><!-- --></A><H3>
getAlphaFactor</H3>
<PRE>
public float <B>getAlphaFactor</B>()</PRE>
<DL>
<DD><p>Retrieves the alpha factor of this Node. Note that this is
 not the effective alpha factor, but only the local alpha factor
 of this Node. To put it another way, the alpha factors of any
 ancestors to this Node are not multiplied in.</p>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the alpha factor of this node; [0, 1]<DT><B>See Also:</B><DD><A HREF="../../../javax/microedition/m3g/Node.html#setAlphaFactor(float)"><CODE>setAlphaFactor</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getParent()"><!-- --></A><H3>
getParent</H3>
<PRE>
public <A HREF="../../../javax/microedition/m3g/Node.html">Node</A> <B>getParent</B>()</PRE>
<DL>
<DD><p>Returns the scene graph parent of this node.</p>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>reference to the parent node, or null if there is no parent</DL>
</DD>
</DL>
<HR>

<A NAME="getTransformTo(javax.microedition.m3g.Node, javax.microedition.m3g.Transform)"><!-- --></A><H3>
getTransformTo</H3>
<PRE>
public boolean <B>getTransformTo</B>(<A HREF="../../../javax/microedition/m3g/Node.html">Node</A>&nbsp;target,
                              <A HREF="../../../javax/microedition/m3g/Transform.html">Transform</A>&nbsp;transform)</PRE>
<DL>
<DD><p>Gets the composite transformation from this node to the given node.
 The composite transformation is defined to be such that it transforms
 a point in the local coordinate system of this node to the coordinate
 system of the given node. For example, the composite transformation
 from this node to its parent is equal to the node transformation of
 this node. Similarly, the composite transformation from this node to
 its child is equal to the inverse of the node transformation of the
 child.</p>

 <p>If there is no path from this node to the given node, this method
 returns <i>false</i>. On the other hand, if there is a path but the
 transformation cannot be computed due to a singular transformation,
 an ArithmeticException is thrown. Beware that a transformation that
 is invertible in one implementation may not be invertible in another,
 because of different arithmetic accuracy. To be safe, avoid matrix
 elements with very small or very large absolute values. See also the
 <a href="package-summary.html#NumericRange">package description</a>.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>target</CODE> - transformation target node<DD><CODE>transform</CODE> - transform object to receive the transformation; if
        there is no path to the target node, the contents of the object
        are left undefined
<DT><B>Returns:</B><DD><i>true</i> if the returned transformation is valid;
         <i>false</i> if there is no path from this node to the
         target node
<DT><B>Throws:</B>
<DD><CODE>java.lang.NullPointerException</CODE> - if <code>target</code> is null
<DD><CODE>java.lang.NullPointerException</CODE> - if <code>transform</code> is null
<DD><CODE>java.lang.ArithmeticException</CODE> - if the inverse of a transformation along
         the path is required, but can not be computed</DL>
</DD>
</DL>
<HR>

<A NAME="align(javax.microedition.m3g.Node)"><!-- --></A><H3>
align</H3>
<PRE>
public final void <B>align</B>(<A HREF="../../../javax/microedition/m3g/Node.html">Node</A>&nbsp;reference)</PRE>
<DL>
<DD><p>Applies alignments to this Node and its descendants.</p>

 <p>The aligned orientation for this node and all its descendants
 are calculated in an undefined order. The rare case where there
 are chains of dependencies between aligned objects is therefore
 not necessarily taken into account.</p>

 <p>The orientation component of the node transformation of each
 aligned node is overwritten with the aligned orientation. The
 pre-existing orientation is not preserved.</p>

 <p>A reference node can be passed in to this method, in order to
 allow alignment of objects to a common reference that is determined
 at run time. This is usually used to align items to the active
 camera, for use as billboards or impostors. Since the active
 camera can change, a reference to it cannot be directly encoded in
 the scene graph. Instead, it is passed in as an argument to this
 method.</p>

 <p>See the class description and <code>setAlignment</code> for more
 information on how to set up and apply alignments.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>reference</CODE> - a node to serve as a common alignment reference
        for nodes that have no fixed reference in either or both
        axes, or null to use this node as the common reference
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>reference</code>
         is not in the same scene graph as this node
<DD><CODE>java.lang.IllegalStateException</CODE> - if the <code>zRef</code> or
         <code>yRef</code> node of any aligned node is not
         in the same scene graph as the aligned node
<DD><CODE>java.lang.IllegalStateException</CODE> - if any node is aligned to itself
         or its descendant (note: this applies to null alignment
         references, as well)
<DD><CODE>java.lang.ArithmeticException</CODE> - if a transformation required in the
         alignment computations cannot be computed</DL>
</DD>
</DL>
<HR>

<A NAME="setAlignment(javax.microedition.m3g.Node, int, javax.microedition.m3g.Node, int)"><!-- --></A><H3>
setAlignment</H3>
<PRE>
public void <B>setAlignment</B>(<A HREF="../../../javax/microedition/m3g/Node.html">Node</A>&nbsp;zRef,
                         int&nbsp;zTarget,
                         <A HREF="../../../javax/microedition/m3g/Node.html">Node</A>&nbsp;yRef,
                         int&nbsp;yTarget)</PRE>
<DL>
<DD><p>Sets this node to align with the given other node(s), or disables
 alignment. Alignment can be used, for example, for automatic "look at"
 behavior for the camera or a spot light, and to create "billboards"
 that are always facing the active camera directly.</p>

 <p>Alignment can be set or disabled for one or both of the Y and Z axes.
 If it is set for both, the Z alignment is applied first, followed by the
 Y alignment. The Y alignment is constrained by the Z alignment. If
 alignment is set for one axis only, it is unconstrained.</p>

 <p>Alignment can be disabled for either or both axes by setting
 the respective alignment targets to <code>NONE</code>. If both
 alignments are disabled, the orientation is left at its present
 state. The original unaligned orientation is <i>not</i> restored.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>zRef</CODE> - the node to use as reference for aligning the Z axis
        of this node, or null to use instead the reference node
        passed as an argument to the <code>align</code> method<DD><CODE>zTarget</CODE> - the axis of <code>zRef</code> to align the Z axis
        of this node with, or <code>ORIGIN</code> to have the Z
        axis point at the origin of <code>zRef</code>, or
        <code>NONE</code> to not align the Z axis at all<DD><CODE>yRef</CODE> - the Y axis equivalent of <code>zRef</code><DD><CODE>yTarget</CODE> - the Y axis equivalent of <code>zTarget</code>
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>yTarget</code> or
         <code>zTarget</code> is not one of the symbolic constants
         listed above
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>(zRef == yRef) &&
         (zTarget == yTarget != NONE)</code>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>zRef</code> or
         <code>yRef</code> is this Node<DT><b>Example:</b><DD><div class="example_title">Common use cases for node alignment.
 
 </div><pre class="example"> setAlignment(<span class="example_literal">null</span>, <span class="example_class">Node</span>.<span class="example_constant">NONE</span>, <span class="example_literal">null</span>, <span class="example_class">Node</span>.<span class="example_constant">NONE</span>);         <span class="example_comment">// Disabled</span>
 setAlignment(<span class="example_literal">null</span>, <span class="example_class">Node</span>.<span class="example_constant">Z_AXIS</span>, <span class="example_literal">null</span>, <span class="example_class">Node</span>.<span class="example_constant">Y_AXIS</span>);     <span class="example_comment">// "Sprite"</span>
 setAlignment(<span class="example_literal">null</span>, <span class="example_class">Node</span>.<span class="example_constant">ORIGIN</span>, world, <span class="example_class">Node</span>.<span class="example_constant">Y_AXIS</span>);    <span class="example_comment">// Billboard</span>
 setAlignment(target, <span class="example_class">Node</span>.<span class="example_constant">ORIGIN</span>, target, <span class="example_class">Node</span>.<span class="example_constant">NONE</span>);   <span class="example_comment">// Target light</span>
 setAlignment(target, <span class="example_class">Node</span>.<span class="example_constant">ORIGIN</span>, world, <span class="example_class">Node</span>.<span class="example_constant">Y_AXIS</span>);  <span class="example_comment">// Target camera</span>
  
 <span class="example_comment">// Note that a camera or light is always facing towards its negative</span>
 <span class="example_comment">// Z axis in its local coordinate system. To make the above camera and</span>
 <span class="example_comment">// light alignments work as expected, the Z axis must be made to point</span>
 <span class="example_comment">// in the opposite direction. This can be done by rotating the node 180</span>
 <span class="example_comment">// degrees about its local Y axis. This, in turn, is most convenient</span>
 <span class="example_comment">// using the scale (S) component of the node transformation. The M</span>
 <span class="example_comment">// component can also be used for this purpose, but the R component</span>
 <span class="example_comment">// can not; that gets overwritten by the aligned orientation.</span>
  
 camera.scale(-1, 1, -1);    <span class="example_comment">// rotate 180 degrees about the Y axis</span></pre></DD></DD></DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>

<!-- ========== START OF NAVBAR ========== -->
<A NAME="navbar_bottom"><!-- --></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Node.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<EM><B>Nov 19, 2003</B></EM></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../javax/microedition/m3g/MorphingMesh.html"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../javax/microedition/m3g/Object3D.html"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html" TARGET="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Node.html" TARGET="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;
<SCRIPT>
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html" TARGET=""><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
<A HREF="../../../allclasses-noframe.html" TARGET=""><B>All Classes</B></A>
</NOSCRIPT>
</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<!-- =========== END OF NAVBAR =========== -->

<HR>
<EM>Copyright &copy 2003 Nokia Corporation. See the <a href="../../../overview-summary.html#Copyright">Copyright Notice</a> for details.</EM>
</BODY>
</HTML>
