<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN""http://www.w3.org/TR/REC-html40/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc on Thu Nov 27 13:54:36 EET 2003 -->
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<TITLE>
Sprite3D (Mobile 3D Graphics API (M3G))
</TITLE>
<META NAME="keywords" CONTENT="javax.microedition.m3g.Sprite3D,Sprite3D class">
<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">
</HEAD>
<SCRIPT>
function asd()
{
parent.document.title="Sprite3D (Mobile 3D Graphics API (M3G))";
}
</SCRIPT>
<BODY BGCOLOR="white" onload="asd();">

<!-- ========== START OF NAVBAR ========== -->
<A NAME="navbar_top"><!-- --></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Sprite3D.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<EM><B>Nov 19, 2003</B></EM></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../javax/microedition/m3g/SkinnedMesh.html"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../javax/microedition/m3g/Texture2D.html"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html" TARGET="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Sprite3D.html" TARGET="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;
<SCRIPT>
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html" TARGET=""><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
<A HREF="../../../allclasses-noframe.html" TARGET=""><B>All Classes</B></A>
</NOSCRIPT>
</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#fields_inherited_from_class_javax.microedition.m3g.Node">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<!-- =========== END OF NAVBAR =========== -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
javax.microedition.m3g</FONT>
<BR>
Class Sprite3D</H2>
<PRE>
java.lang.Object
  |
  +--<A HREF="../../../javax/microedition/m3g/Object3D.html">javax.microedition.m3g.Object3D</A>
        |
        +--<A HREF="../../../javax/microedition/m3g/Transformable.html">javax.microedition.m3g.Transformable</A>
              |
              +--<A HREF="../../../javax/microedition/m3g/Node.html">javax.microedition.m3g.Node</A>
                    |
                    +--<B>javax.microedition.m3g.Sprite3D</B>
</PRE>
<HR>
<DL>
<DT>public class <B>Sprite3D</B><DT>extends <A HREF="../../../javax/microedition/m3g/Node.html">Node</A></DL>

<P>
<p>A scene graph node that represents a 2-dimensional image with a 3D
position.</p>

<p>Sprite3D is a fast, but functionally restricted alternative to
textured geometry. A Sprite3D is rendered as a screen-aligned
rectangular array of pixels with a constant depth. The apparent size
of a sprite may be specified directly in pixels (an unscaled sprite)
or indirectly using the transformation from the Sprite3D node to the
camera space (a scaled sprite).</p>

<p>The structure of a Sprite3D object is shown in the figure below.</p>

<center><img src="./doc-files/Sprite3D-components.png"/></center>

<h3>Sprite image data</h3>

<p>The sprite image is stored as a reference to an Image2D. The image
may be in any of the formats defined in Image2D. The width and height
of the image are not limited in any way; in particular, they need not
be powers of two. However, there is an implementation defined maximum
size for the crop rectangle (the area of the sprite that is actually
displayed). This can be queried with <A HREF="../../../javax/microedition/m3g/Graphics3D.html#getProperties()"><CODE>getProperties</CODE></A>.</p>

<p>The displayed sprite image can be mirrored with respect to the X
and/or Y axes by specifying a crop rectangle with a negative width
and/or height, respectively.</p>

<p>If the referenced Image2D is mutable and is modified while it is
bound to a Sprite3D, or a new Image2D is bound as the sprite image, the
modifications are immediately reflected in the Sprite3D. Be aware,
however, that changing or updating the sprite image may trigger
time-consuming operations.</p>

<h3>Sprite positioning and scaling</h3>

<p>The position of a sprite on screen is determined by projecting the
origin of its coordinate system to screen coordinates. The resulting
2D position is used as the center of the displayed pixel array. If
this causes any part of the sprite to be placed off screen, then the
sprite is clipped to the visible portion of the viewport as usual
(refer to Graphics3D).</p>

<p>The depth value of a sprite is constant across the image, and is the
depth of the origin of the Sprite3D coordinate system.</p>

<p>The width and height of an <i>unscaled</i> sprite on screen are measured
in pixels, and they are equal to the (absolute) width and height of the crop
rectangle. Recall that the crop rectangle dimensions may be negative to flip
the pixels; this has no effect on the size of the sprite.</p>

<p>The width and height of a <i>scaled</i> sprite on screen are computed
basically as if the sprite were a rectangle with unit-length sides, lying
on the XY plane of its local coordinate system and centered at its origin.
See the Implementation guidelines below for the details.</p>

<p>Because a sprite is always displayed as a screen-aligned rectangle,
the effects of other than rigid-body transformations on sprites may
not be immediately intuitive, even though they are well-defined. It is
advised that, for example, non-uniform scaling and skewing be avoided
in sprite modelview matrices. Similarly, oblique projections should be
used with caution when sprites are present in the displayed scene.</p>

<h3>Sprite rendering attributes</h3>

<p>The rendering attributes for a Sprite3D are determined by its
Appearance, as is the case with Mesh objects. There are a number of
properties in Appearance, however, that do not have a meaningful
interpretation in this context. Thus, only the CompositingMode and Fog
components and the layer index are taken into account when rendering a
sprite. The rest of the components are ignored. This implies, in
particular, that lighting does not apply for sprites.</p>

<p>Nearly all properties and methods inherited from Node are
applicable for sprites also. The only property that is ignored
when rendering is the alpha factor.</p>

<h3>Sprite picking</h3>

<p>Only scaled sprites can be picked. This is because the dimensions of
an unscaled sprite are only defined in screen space, that is, after the
viewport transformation. Since the viewport parameters are not available
to the pick method, the dimensions of an unscaled sprite can not be
computed.</p>

<p>Picking of scaled sprites is analogous to how they are rendered.
Picking is done in normalized device coordinates (after projection,
before viewport transformation), where the position, depth value and
dimensions of scaled sprites are well defined. See the Implementation
guidelines for how to calculate these.</p>

<p>Since the sprite size calculation requires a Camera, sprites are
only pickable through the viewing plane, not from an arbitrary
position in the scene. That is, of the two <code>pick</code> variants
in Group, only the one that takes in a Camera as a parameter can be
used in sprite picking. The other variant simply ignores all sprite
nodes.</p>

<p>If a sprite is intersected by the pick ray, the pixel in the sprite
image at the intersection point will be further tested for transparency.
If the pixel is fully transparent, the sprite is not picked and the pick
ray will continue towards objects that are further away. If the pixel is
not fully transparent, the sprite is picked. A pixel is defined to be
fully transparent if and only if it fails the alpha test (see <A HREF="../../../javax/microedition/m3g/CompositingMode.html#setAlphaThreshold(float)"><CODE>CompositingMode.setAlphaThreshold(float)</CODE></A>).</p>

<h3>Implementation guidelines</h3>

<p>Sprites do not provide any functionality that would not be available
otherwise; they can always be substituted with textured meshes. However,
the existence of the sprite primitive acts as a signal to the renderer
that a very specific subset of functionality is required. This allows the
rendering pipeline to avoid the overhead of transforming and lighting full
geometry. It also allows the rasterizer to select an optimized drawing
routine to place the pixels on the screen, without the potentially complex
interpolation of parameters across the rectangle. This can be used to make
sprites very much faster than textured meshes (especially in software)
which in turn increases the richness of content that can be offered at
the low end.</p>

<h4>Implementing with textures</h4>

<p>Sprite3D can be implemented with textured rectangles. The restriction
on the maximum crop rectangle size is in place because otherwise
implementations using this method would be forced to downsample larger
crop rectangles to the maximum texture size; an expensive operation.</p>

<p>When implementing unscaled sprites with texture mapping, care should
be taken that rounding errors or similar do not yield unwelcome artifacts,
such as pixel columns appearing and disappearing depending on the screen
position of the sprite. This is particularly important for text labels.</p>

<p>Filtering of scaled sprites can be implemented with the simple nearest
neighbor algorithm, but implementations are free to apply more sophisticated
schemes, such as mipmapping. No application control over the filtering
behavior is provided, however; if that is required, textured rectangles
can be used instead.</p>

<h4>Computing the position and size</h4>

<p>The position of a sprite on the viewport is simply the projected
location of the Sprite3D node's origin. Similarly, the depth of the
sprite is the projected depth of the origin.</p>

<p>The size of a sprite, in pixels, depends on whether the sprite is
scaled or not. An unscaled sprite is the same size as its crop
rectangle. Calculating the size of a scaled sprite is slightly more
complicated. In principle, it only involves projecting the Sprite3D
node's X and Y axes into screen space and computing their length,
but to make the calculation well defined under arbitrary transformations,
a few additional steps are required. The exact formula is given below.</p>

<p>Let us define <b>M</b> and <b>P</b> as the current modelview and
projection matrices. The modelview matrix <b>M</b> is the concatenated
transformation from the Sprite3D node into camera space (taking into
account all of the transformation components of the Sprite3D, including
the user-settable static matrix), and <b>P</b> is the projection
matrix of the current camera.</p>

<p>Let us first transform the origin and two reference points,
corresponding to the X and Y axes, from the Sprite3D node's
coordinate system into camera space:</p>

<blockquote>
<b>o</b>' = <b>M</b> (0, 0, 0, 1)<sup>T</sup><br>
<b>x</b>' = <b>M</b> (1, 0, 0, 1)<sup>T</sup><br>
<b>y</b>' = <b>M</b> (0, 1, 0, 1)<sup>T</sup>
</blockquote>

<p>We then compute the distances from the origin to the X and Y
reference points. If the bottom row of the modelview matrix is
not (0 0 0 1), the transformed points may have W values different
from each other. The points are thus brought into an equal scale
(W = 1) before computing the distance.</p>

<blockquote>
dx = | <b>x</b>'/x'<sub>w</sub> - <b>o</b>'/o'<sub>w</sub> |<br>
dy = | <b>y</b>'/y'<sub>w</sub> - <b>o</b>'/o'<sub>w</sub> |
</blockquote>

<p>Note that the W components of the homogeneous points cancel
out in the subtraction, and the lengths computed are those of
the 3D vectors. We then define (new) X and Y reference points
that lie on the X and Y axes of the camera and whose distances
from the origin are dx and dy, respectively. Applying the
projection matrix, we transform the origin and the reference
points into clip space:</p>

<blockquote>
<b>o</b>'' = <b>P</b> <b>o</b>'<br>
<b>x</b>'' = <b>P</b> [<b>o</b>' + (dx, 0, 0, 0)<sup>T</sup>]<br>
<b>y</b>'' = <b>P</b> [<b>o</b>' + (0, dy, 0, 0)<sup>T</sup>]
</blockquote>

<p>Again, we compute the distances from the origin to the X and
Y reference points. This gives us the dimensions of the sprite
in normalized device coordinates.</p>

<blockquote>
sx = | <b>x</b>''/x''<sub>w</sub> - <b>o</b>''/o''<sub>w</sub> |<br>
sy = | <b>y</b>''/y''<sub>w</sub> - <b>o</b>''/o''<sub>w</sub> |
</blockquote>

<p>These dimensions are used when testing the sprite for an
intersection with a pick ray. For rendering the sprite, we
need to apply the viewport transformation (see Graphics3D)
to obtain the final on-screen size in pixels:</p>

<blockquote>
w = 0.5 sx w<sub>vp</sub><br>
h = 0.5 sy h<sub>vp</sub>
</blockquote>

<p>where w<sub>vp</sub> and h<sub>vp</sub> are the dimensions of the
viewport.</p>

<p>Note that this formula may produce unintuitive results if the
modelview matrix <b>M</b> incorporates, for example, non-uniform
scaling and/or skewing components. However, the size computation
is well-defined and predictable.</p>

<p>Also note that in the equations above, we transform and project
the X and Y axes of the sprite node as two homogeneous points each;
implementations may obtain the same result by transforming them
differently.</p>
<P>

<P>
<DL>
<DT><B>See Also:</B><DD><a href="../../../file-format.html#Sprite3D">Binary format</a></DL>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->


<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Field Summary</B></FONT></TD>
</TR>
</TABLE>
&nbsp;<A NAME="fields_inherited_from_class_javax.microedition.m3g.Node"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Fields inherited from class javax.microedition.m3g.<A HREF="../../../javax/microedition/m3g/Node.html">Node</A></B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../javax/microedition/m3g/Node.html#NONE">NONE</A>, <A HREF="../../../javax/microedition/m3g/Node.html#ORIGIN">ORIGIN</A>, <A HREF="../../../javax/microedition/m3g/Node.html#X_AXIS">X_AXIS</A>, <A HREF="../../../javax/microedition/m3g/Node.html#Y_AXIS">Y_AXIS</A>, <A HREF="../../../javax/microedition/m3g/Node.html#Z_AXIS">Z_AXIS</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Sprite3D.html#Sprite3D(boolean, javax.microedition.m3g.Image2D, javax.microedition.m3g.Appearance)">Sprite3D</A></B>(boolean&nbsp;scaled,
         <A HREF="../../../javax/microedition/m3g/Image2D.html">Image2D</A>&nbsp;image,
         <A HREF="../../../javax/microedition/m3g/Appearance.html">Appearance</A>&nbsp;appearance)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructs a new Sprite3D with the given scaling mode, image
 and appearance. </TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Method Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../javax/microedition/m3g/Appearance.html">Appearance</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Sprite3D.html#getAppearance()">getAppearance</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the current Appearance of this Sprite3D.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Sprite3D.html#getCropHeight()">getCropHeight</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the current cropping rectangle height within the source
 image. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Sprite3D.html#getCropWidth()">getCropWidth</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the current cropping rectangle width within the source
 image. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Sprite3D.html#getCropX()">getCropX</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves the current cropping rectangle X offset relative
 to the source image top left corner.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Sprite3D.html#getCropY()">getCropY</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves the current cropping rectangle Y offset relative
 to the source image top left corner.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../javax/microedition/m3g/Image2D.html">Image2D</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Sprite3D.html#getImage()">getImage</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the current Sprite3D image.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Sprite3D.html#isScaled()">isScaled</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the automatic scaling status of this Sprite3D. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Sprite3D.html#setAppearance(javax.microedition.m3g.Appearance)">setAppearance</A></B>(<A HREF="../../../javax/microedition/m3g/Appearance.html">Appearance</A>&nbsp;appearance)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the Appearance of this Sprite3D. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Sprite3D.html#setCrop(int, int, int, int)">setCrop</A></B>(int&nbsp;cropX,
        int&nbsp;cropY,
        int&nbsp;width,
        int&nbsp;height)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets a cropping rectangle within the source image. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Sprite3D.html#setImage(javax.microedition.m3g.Image2D)">setImage</A></B>(<A HREF="../../../javax/microedition/m3g/Image2D.html">Image2D</A>&nbsp;image)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the sprite image to display. </TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_javax.microedition.m3g.Node"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Methods inherited from class javax.microedition.m3g.<A HREF="../../../javax/microedition/m3g/Node.html">Node</A></B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../javax/microedition/m3g/Node.html#align(javax.microedition.m3g.Node)">align</A>, <A HREF="../../../javax/microedition/m3g/Node.html#getAlphaFactor()">getAlphaFactor</A>, <A HREF="../../../javax/microedition/m3g/Node.html#getParent()">getParent</A>, <A HREF="../../../javax/microedition/m3g/Node.html#getScope()">getScope</A>, <A HREF="../../../javax/microedition/m3g/Node.html#getTransformTo(javax.microedition.m3g.Node, javax.microedition.m3g.Transform)">getTransformTo</A>, <A HREF="../../../javax/microedition/m3g/Node.html#isPickingEnabled()">isPickingEnabled</A>, <A HREF="../../../javax/microedition/m3g/Node.html#isRenderingEnabled()">isRenderingEnabled</A>, <A HREF="../../../javax/microedition/m3g/Node.html#setAlignment(javax.microedition.m3g.Node, int, javax.microedition.m3g.Node, int)">setAlignment</A>, <A HREF="../../../javax/microedition/m3g/Node.html#setAlphaFactor(float)">setAlphaFactor</A>, <A HREF="../../../javax/microedition/m3g/Node.html#setPickingEnable(boolean)">setPickingEnable</A>, <A HREF="../../../javax/microedition/m3g/Node.html#setRenderingEnable(boolean)">setRenderingEnable</A>, <A HREF="../../../javax/microedition/m3g/Node.html#setScope(int)">setScope</A></CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_javax.microedition.m3g.Transformable"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Methods inherited from class javax.microedition.m3g.<A HREF="../../../javax/microedition/m3g/Transformable.html">Transformable</A></B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../javax/microedition/m3g/Transformable.html#getCompositeTransform(javax.microedition.m3g.Transform)">getCompositeTransform</A>, <A HREF="../../../javax/microedition/m3g/Transformable.html#getOrientation(float[])">getOrientation</A>, <A HREF="../../../javax/microedition/m3g/Transformable.html#getScale(float[])">getScale</A>, <A HREF="../../../javax/microedition/m3g/Transformable.html#getTransform(javax.microedition.m3g.Transform)">getTransform</A>, <A HREF="../../../javax/microedition/m3g/Transformable.html#getTranslation(float[])">getTranslation</A>, <A HREF="../../../javax/microedition/m3g/Transformable.html#postRotate(float, float, float, float)">postRotate</A>, <A HREF="../../../javax/microedition/m3g/Transformable.html#preRotate(float, float, float, float)">preRotate</A>, <A HREF="../../../javax/microedition/m3g/Transformable.html#scale(float, float, float)">scale</A>, <A HREF="../../../javax/microedition/m3g/Transformable.html#setOrientation(float, float, float, float)">setOrientation</A>, <A HREF="../../../javax/microedition/m3g/Transformable.html#setScale(float, float, float)">setScale</A>, <A HREF="../../../javax/microedition/m3g/Transformable.html#setTransform(javax.microedition.m3g.Transform)">setTransform</A>, <A HREF="../../../javax/microedition/m3g/Transformable.html#setTranslation(float, float, float)">setTranslation</A>, <A HREF="../../../javax/microedition/m3g/Transformable.html#translate(float, float, float)">translate</A></CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_javax.microedition.m3g.Object3D"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Methods inherited from class javax.microedition.m3g.<A HREF="../../../javax/microedition/m3g/Object3D.html">Object3D</A></B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../javax/microedition/m3g/Object3D.html#addAnimationTrack(javax.microedition.m3g.AnimationTrack)">addAnimationTrack</A>, <A HREF="../../../javax/microedition/m3g/Object3D.html#animate(int)">animate</A>, <A HREF="../../../javax/microedition/m3g/Object3D.html#duplicate()">duplicate</A>, <A HREF="../../../javax/microedition/m3g/Object3D.html#find(int)">find</A>, <A HREF="../../../javax/microedition/m3g/Object3D.html#getAnimationTrack(int)">getAnimationTrack</A>, <A HREF="../../../javax/microedition/m3g/Object3D.html#getAnimationTrackCount()">getAnimationTrackCount</A>, <A HREF="../../../javax/microedition/m3g/Object3D.html#getReferences(javax.microedition.m3g.Object3D[])">getReferences</A>, <A HREF="../../../javax/microedition/m3g/Object3D.html#getUserID()">getUserID</A>, <A HREF="../../../javax/microedition/m3g/Object3D.html#getUserObject()">getUserObject</A>, <A HREF="../../../javax/microedition/m3g/Object3D.html#removeAnimationTrack(javax.microedition.m3g.AnimationTrack)">removeAnimationTrack</A>, <A HREF="../../../javax/microedition/m3g/Object3D.html#setUserID(int)">setUserID</A>, <A HREF="../../../javax/microedition/m3g/Object3D.html#setUserObject(java.lang.Object)">setUserObject</A></CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Methods inherited from class java.lang.Object</B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>equals, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->


<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="Sprite3D(boolean, javax.microedition.m3g.Image2D, javax.microedition.m3g.Appearance)"><!-- --></A><H3>
Sprite3D</H3>
<PRE>
public <B>Sprite3D</B>(boolean&nbsp;scaled,
                <A HREF="../../../javax/microedition/m3g/Image2D.html">Image2D</A>&nbsp;image,
                <A HREF="../../../javax/microedition/m3g/Appearance.html">Appearance</A>&nbsp;appearance)</PRE>
<DL>
<DD><p>Constructs a new Sprite3D with the given scaling mode, image
 and appearance. The sprite image and appearance can be changed
 at any time, but the scaling mode is fixed at construction. If
 the appearance is null, rendering and picking of the sprite is
 disabled.</p>

 <p>The crop rectangle is set such that its top left corner is
 at the top left corner of the image, and its width and height
 are equal to the dimensions of the image. However, if the width
 (or height) of the crop rectangle would exceed the implementation
 defined maximum, the width (or height) is set to the maximum value
 instead. The maximum crop rectangle size can be queried with
 <A HREF="../../../javax/microedition/m3g/Graphics3D.html#getProperties()"><CODE>getProperties</CODE></A>.</p>
<P>
<DT><B>Parameters:</B><DD><CODE>scaled</CODE> - <i>true</i> to make this Sprite3D scaled;
        <i>false</i> to disable scaling<DD><CODE>image</CODE> - pixel data and image properties to use
        to draw this Sprite3D<DD><CODE>appearance</CODE> - the Appearance to use for this Sprite3D,
        or null to disable this sprite initially
<DT><B>Throws:</B>
<DD><CODE>java.lang.NullPointerException</CODE> - if <code>image</code> is null</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Method Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="isScaled()"><!-- --></A><H3>
isScaled</H3>
<PRE>
public boolean <B>isScaled</B>()</PRE>
<DL>
<DD><p>Returns the automatic scaling status of this Sprite3D. Note
 that the scaling mode cannot be changed after construction.</p>
<P>
<DD><DL>

<DT><B>Returns:</B><DD><i>true</i> if this sprite is scaled; <i>false</i> if
         it is unscaled</DL>
</DD>
</DL>
<HR>

<A NAME="setAppearance(javax.microedition.m3g.Appearance)"><!-- --></A><H3>
setAppearance</H3>
<PRE>
public void <B>setAppearance</B>(<A HREF="../../../javax/microedition/m3g/Appearance.html">Appearance</A>&nbsp;appearance)</PRE>
<DL>
<DD><p>Sets the Appearance of this Sprite3D. Note that the PolygonMode,
 Texture and Material components of the Appearance are ignored.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>appearance</CODE> - the Appearance to set, or null to disable this sprite<DT><B>See Also:</B><DD><A HREF="../../../javax/microedition/m3g/Sprite3D.html#getAppearance()"><CODE>getAppearance</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getAppearance()"><!-- --></A><H3>
getAppearance</H3>
<PRE>
public <A HREF="../../../javax/microedition/m3g/Appearance.html">Appearance</A> <B>getAppearance</B>()</PRE>
<DL>
<DD><p>Gets the current Appearance of this Sprite3D.</p>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the current Appearance of this sprite<DT><B>See Also:</B><DD><A HREF="../../../javax/microedition/m3g/Sprite3D.html#setAppearance(javax.microedition.m3g.Appearance)"><CODE>setAppearance</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setImage(javax.microedition.m3g.Image2D)"><!-- --></A><H3>
setImage</H3>
<PRE>
public void <B>setImage</B>(<A HREF="../../../javax/microedition/m3g/Image2D.html">Image2D</A>&nbsp;image)</PRE>
<DL>
<DD><p>Sets the sprite image to display. The crop rectangle is reset in
 the same way as in the constructor.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>image</CODE> - pixel data and image properties to use to draw this sprite
<DT><B>Throws:</B>
<DD><CODE>java.lang.NullPointerException</CODE> - if <code>image</code> is null<DT><B>See Also:</B><DD><A HREF="../../../javax/microedition/m3g/Sprite3D.html#getImage()"><CODE>getImage</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getImage()"><!-- --></A><H3>
getImage</H3>
<PRE>
public <A HREF="../../../javax/microedition/m3g/Image2D.html">Image2D</A> <B>getImage</B>()</PRE>
<DL>
<DD><p>Gets the current Sprite3D image.</p>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the Image2D object used to draw this sprite<DT><B>See Also:</B><DD><A HREF="../../../javax/microedition/m3g/Sprite3D.html#setImage(javax.microedition.m3g.Image2D)"><CODE>setImage</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setCrop(int, int, int, int)"><!-- --></A><H3>
setCrop</H3>
<PRE>
public void <B>setCrop</B>(int&nbsp;cropX,
                    int&nbsp;cropY,
                    int&nbsp;width,
                    int&nbsp;height)</PRE>
<DL>
<DD><p>Sets a cropping rectangle within the source image. This
 allows a subsection of the image to be used as the source for
 the pixels of the sprite. This can be used for selection of
 individual frames of animation, scrolling of captions, or other
 effects.</p>

 <p>The position of the upper left corner of the crop rectangle
 is given in pixels, relative to the upper left corner of the
 Image2D. Note that the relative position may be negative in
 either or both axes.</p>

 <p>If the crop rectangle has zero width or height, the sprite
 is not rendered or picked. If, on the other hand, the width
 and/or height are negative, the sprite image is flipped in the
 X and/or Y axes, respectively. Note that the crop rectangle
 remains in the same position within the source image regardless
 of the signs of the width and height; only the drawing order of
 the pixels is changed.</p>
     
 <p>The absolute values of the crop width and height are limited
 to an implementation defined maximum that can be queried from
 Graphics3D.</p>

 <p>Wrapping of the source image is not supported. If the crop
 rectangle lies completely or partially outside of the image
 boundaries, the (imaginary) pixels outside of the image are
 treated as if failing the alpha test. In other words, they
 are not rendered, but the on-screen size and pixel zoom factor
 of the sprite remain the same as if the crop rectangle were
 completely inside the image.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>cropX</CODE> - the X position of the top left of the crop
        rectangle, in pixels<DD><CODE>cropY</CODE> - the Y position of the top left of the crop
        rectangle, in pixels<DD><CODE>width</CODE> - the width of the crop rectangle, in pixels<DD><CODE>height</CODE> - the height of the crop rectangle, in pixels
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>width</code> or
         <code>height</code> exceeds the implementation defined
         maximum</DL>
</DD>
</DL>
<HR>

<A NAME="getCropX()"><!-- --></A><H3>
getCropX</H3>
<PRE>
public int <B>getCropX</B>()</PRE>
<DL>
<DD><p>Retrieves the current cropping rectangle X offset relative
 to the source image top left corner.</p>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the X offset of the cropping rectangle<DT><B>See Also:</B><DD><A HREF="../../../javax/microedition/m3g/Sprite3D.html#setCrop(int, int, int, int)"><CODE>setCrop</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getCropY()"><!-- --></A><H3>
getCropY</H3>
<PRE>
public int <B>getCropY</B>()</PRE>
<DL>
<DD><p>Retrieves the current cropping rectangle Y offset relative
 to the source image top left corner.</p>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the Y offset of the cropping rectangle<DT><B>See Also:</B><DD><A HREF="../../../javax/microedition/m3g/Sprite3D.html#setCrop(int, int, int, int)"><CODE>setCrop</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getCropWidth()"><!-- --></A><H3>
getCropWidth</H3>
<PRE>
public int <B>getCropWidth</B>()</PRE>
<DL>
<DD><p>Gets the current cropping rectangle width within the source
 image. The width may be negative, in which case the image data
 is flipped in the X axis.</p>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the width of the cropping rectangle<DT><B>See Also:</B><DD><A HREF="../../../javax/microedition/m3g/Sprite3D.html#setCrop(int, int, int, int)"><CODE>setCrop</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getCropHeight()"><!-- --></A><H3>
getCropHeight</H3>
<PRE>
public int <B>getCropHeight</B>()</PRE>
<DL>
<DD><p>Gets the current cropping rectangle height within the source
 image. The height may be negative, in which case the image data
 is flipped in the Y axis.</p>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the height of the cropping rectangle<DT><B>See Also:</B><DD><A HREF="../../../javax/microedition/m3g/Sprite3D.html#setCrop(int, int, int, int)"><CODE>setCrop</CODE></A></DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>

<!-- ========== START OF NAVBAR ========== -->
<A NAME="navbar_bottom"><!-- --></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Sprite3D.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<EM><B>Nov 19, 2003</B></EM></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../javax/microedition/m3g/SkinnedMesh.html"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../javax/microedition/m3g/Texture2D.html"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html" TARGET="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Sprite3D.html" TARGET="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;
<SCRIPT>
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html" TARGET=""><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
<A HREF="../../../allclasses-noframe.html" TARGET=""><B>All Classes</B></A>
</NOSCRIPT>
</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#fields_inherited_from_class_javax.microedition.m3g.Node">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<!-- =========== END OF NAVBAR =========== -->

<HR>
<EM>Copyright &copy 2003 Nokia Corporation. See the <a href="../../../overview-summary.html#Copyright">Copyright Notice</a> for details.</EM>
</BODY>
</HTML>
