<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN""http://www.w3.org/TR/REC-html40/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc on Tue Apr 06 10:44:26 EEST 2004 -->
<TITLE>
DirectGraphics (Nokia UI API)
</TITLE>
<META NAME="keywords" CONTENT="com.nokia.mid.ui.DirectGraphics,DirectGraphics interface">
<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../../stylesheet.css" TITLE="Style">
</HEAD>
<SCRIPT>
function asd()
{
parent.document.title="DirectGraphics (Nokia UI API)";
}
</SCRIPT>
<BODY BGCOLOR="white" onload="asd();">

<!-- ========== START OF NAVBAR ========== -->
<A NAME="navbar_top"><!-- --></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<a href=http://forum.nokia.com/java target=_top><img src=../../../../doc-files/forum_logo.gif border=0></a></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;PREV CLASS&nbsp;
&nbsp;NEXT CLASS</FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../index.html" TARGET="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="DirectGraphics.html" TARGET="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;
<SCRIPT>
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html" TARGET=""><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
<A HREF="../../../../allclasses-noframe.html" TARGET=""><B>All Classes</B></A>
</NOSCRIPT>
</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<!-- =========== END OF NAVBAR =========== -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
com.nokia.mid.ui</FONT>
<BR>
Interface DirectGraphics</H2>
<HR>
<DL>
<DT>public interface <B>DirectGraphics</B></DL>

<P>
DirectGraphics contains some graphics extensions for MIDP Graphics, with
 which polygons and triangles can be drawn and filled, images can be
 rotated or flipped, alpha channel color supported and raw pixel data can
 be directly obtained from the graphics context or drawn to it.
 <p>
 <A HREF="../../../../com/nokia/mid/ui/DirectUtils.html#getDirectGraphics(javax.microedition.lcdui.Graphics)"><CODE>DirectUtils.getDirectGraphics(Graphics g)</CODE></A> method can be used to
 convert lcdui Graphics to Nokia DirectGraphics object:
 <pre>
 DirectGraphics dg = DirectUtils.getDirectGraphics(g);
 </pre>
 The operations to DirectGraphics reference will also affect the original
 graphics context, for example, setting the color with DirectGraphics
 will change the current painting color for Graphics and vice versa. In 
 fact, the developer can see DirectGraphics as a new way to do calls to
 Graphics. DirectGraphics does not inherit the standard Graphics 
 because of API dependency. Following methods in Graphics affect also 
 rendering operations of DirectGraphics:
 <ul>
 <li>clipRect(int x, int y, int width, int height)
 <li>setClip(int x, int y, int width, int height)
 <li>setColor(int RGB)
 <li>setColor(int red, int green, int blue)
 <li>setGrayScale(int value)
 <li>setStrokeStyle(int style)
 <li>translate(int x, int y)
 </ul>
 Following method in DirectGraphics affect rendering operations via
 Graphics:
 <ul>
 <li>setARGBColor(int argbColor)
 </ul>
 All rendering operations via Graphics or DirectGraphics draw on same
 graphics context.
 <p>
 ARGB values used with some methods of this interface are interpreted
 with the least significant eight bits giving the blue component, the 
 next eight more significant bits, the green component, the next eight 
 more significant bits, the red component, and the next eight more
 significant bits, the alpha component. In other words, the color
 component is specified in the form of 0xAARRGGBB. This corresponds to
 the native format specified by <A HREF="../../../../com/nokia/mid/ui/DirectGraphics.html#TYPE_INT_8888_ARGB"><CODE>TYPE_INT_8888_ARGB</CODE></A>.
 <p>
 Manipulation parameters to drawPixels are formed by bitwise ORring
 FLIP_HORIZONTAL or FLIP_VERTICAL with a degree value: ROTATE_90,
 ROTATE_180 or ROTATE_270. Currently only these fixed rotation values 
 are supported. The image is rotated counter-clockwise. The result from 
 a combined manipulation is that first the rotation will be done, then 
 the vertical flip, and finally the horizontal flip. Since the 
 manipulation parameters are passed in a single integer the MIDlet 
 cannot dictate the order of flips or rotation. There is always at most 
 a single rotation, a single horizontal flip and a single vertical flip 
 done. For instance, if a manipulation argument is: (FLIP_HORIZONTAL |
 FLIP_VERTICAL | ROTATE_90 ), the image is rotated 90 degrees
 counter-clockwise and after that it is flipped vertically and then
 horizontally. In methods that have anchor point parameter the
 manipulation is done before any anchor point is considere and the 
 anchor point is applied after the manipulation.
 <p>
 <a name="Alpha"><b>Alpha channel</b></a>
 <p>
 High-order bits in color values specify opacity.
 A value of 0 means fully transparent pixel, non-zero values are treated
 as non-transparent (largest possible value means fully opaque and 
 values in between either fully opaque or semi-opaque). As an example, 
 in int based color values 0x00RRGGBB specifies a fully transparent 
 pixel and 0xFFRRGGBB specifies a fully opaque pixel. Implementations 
 must treat any pixel with a non-zero top byte as being non-transparent.
 <p>
 For on-screen graphics contexts the get operations will return
 transparency information as fully opaque. On rendering operations 
 Porter-Duff Source Over Destination rule is used (T. Porter and T. 
 Duff, "Compositing Digital Images", SIGGRAPH 84, 253-259).
 <p>
 <a name="setcoloralpha">
 <b>Note on alpha use with MIDP Graphics operations</b>
 </a>
 <p>
 Alpha value set with setARGBColor(int) is used in 
 javax.microedition.lcdui.Graphics drawing
 methods that use the current color of Graphics.
 <p>
 The alpha value is set to fully opaque when calls to following
 Graphics methods are made:
 <ul>
 <li>setColor(int RGB)
 <li>setGrayScale(int value)
 <li>setColor(int red, int green, int blue)
 </ul>
 <p>
<P>

<P>
<DL>
<DT><B>Since:</B></DT>
  <DD>1.0</DD>
</DL>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->


<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Field Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/nokia/mid/ui/DirectGraphics.html#FLIP_HORIZONTAL">FLIP_HORIZONTAL</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constant for horizontal image flipping.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/nokia/mid/ui/DirectGraphics.html#FLIP_VERTICAL">FLIP_VERTICAL</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constant for vertical image flipping.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/nokia/mid/ui/DirectGraphics.html#ROTATE_180">ROTATE_180</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constant for rotating an image 180 degrees counter-clockwise.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/nokia/mid/ui/DirectGraphics.html#ROTATE_270">ROTATE_270</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constant for rotating an image 270 degrees counter-clockwise.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/nokia/mid/ui/DirectGraphics.html#ROTATE_90">ROTATE_90</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constant for rotating an image 90 degrees counter-clockwise. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/nokia/mid/ui/DirectGraphics.html#TYPE_BYTE_1_GRAY">TYPE_BYTE_1_GRAY</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 bit format, 2 distinct color values (on/off), stored as
  a byte. 8 pixel values in a single byte, packed as closely
  as possible.
  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/nokia/mid/ui/DirectGraphics.html#TYPE_BYTE_1_GRAY_VERTICAL">TYPE_BYTE_1_GRAY_VERTICAL</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 bit format, 2 distinct color values (on/off), stored as
  a byte. 8 pixel values are stored in a single byte.
  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/nokia/mid/ui/DirectGraphics.html#TYPE_BYTE_2_GRAY">TYPE_BYTE_2_GRAY</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2 bit format, 4 gray scale colors. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/nokia/mid/ui/DirectGraphics.html#TYPE_BYTE_332_RGB">TYPE_BYTE_332_RGB</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3 bits for red, 3 bits for green, and 2 bits for blue component
  in a pixel, stored as a byte.
  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/nokia/mid/ui/DirectGraphics.html#TYPE_BYTE_4_GRAY">TYPE_BYTE_4_GRAY</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4 bit format, 16 gray scale colors. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/nokia/mid/ui/DirectGraphics.html#TYPE_BYTE_8_GRAY">TYPE_BYTE_8_GRAY</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8 bit format, 256 gray scale colors. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/nokia/mid/ui/DirectGraphics.html#TYPE_INT_888_RGB">TYPE_INT_888_RGB</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8 bits for red, green and blue component in a pixel (0x00RRGGBB).
  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/nokia/mid/ui/DirectGraphics.html#TYPE_INT_8888_ARGB">TYPE_INT_8888_ARGB</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8 bits for alpha, red, green and blue component in a pixel
  (0xAARRGGBB).
  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/nokia/mid/ui/DirectGraphics.html#TYPE_USHORT_1555_ARGB">TYPE_USHORT_1555_ARGB</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 bit for alpha, 5 bits for red, green and blue component in a pixel.
  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/nokia/mid/ui/DirectGraphics.html#TYPE_USHORT_444_RGB">TYPE_USHORT_444_RGB</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4 bits for red, green and blue component in a pixel, stored as a
  short (0x0RGB).
  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/nokia/mid/ui/DirectGraphics.html#TYPE_USHORT_4444_ARGB">TYPE_USHORT_4444_ARGB</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4 bits for alpha, red, green and blue component in a pixel, stored as
  a short (0xARGB).
  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/nokia/mid/ui/DirectGraphics.html#TYPE_USHORT_555_RGB">TYPE_USHORT_555_RGB</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5 bits for red, green and blue component in a pixel.
  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/nokia/mid/ui/DirectGraphics.html#TYPE_USHORT_565_RGB">TYPE_USHORT_565_RGB</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5 bits for red, 6 bits for green and 5 bits for blue component in a
  pixel.
  </TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->


<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Method Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/nokia/mid/ui/DirectGraphics.html#drawImage(javax.microedition.lcdui.Image, int, int, int, int)">drawImage</A></B>(javax.microedition.lcdui.Image&nbsp;img,
          int&nbsp;x,
          int&nbsp;y,
          int&nbsp;anchor,
          int&nbsp;manipulation)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;<I>As of Nokia UI API 1.1 in devices with MIDP 2.0 or higher, replaced by javax.microedition.lcdui.Graphics.drawRegion(javax.microedition.lcdui.Image, int, int, int, int, int, int, int, int).</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/nokia/mid/ui/DirectGraphics.html#drawPixels(byte[], byte[], int, int, int, int, int, int, int, int)">drawPixels</A></B>(byte[]&nbsp;pixels,
           byte[]&nbsp;transparencyMask,
           int&nbsp;offset,
           int&nbsp;scanlength,
           int&nbsp;x,
           int&nbsp;y,
           int&nbsp;width,
           int&nbsp;height,
           int&nbsp;manipulation,
           int&nbsp;format)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies or draws the pixel data directly to the graphics context to a
 specific location. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/nokia/mid/ui/DirectGraphics.html#drawPixels(int[], boolean, int, int, int, int, int, int, int, int)">drawPixels</A></B>(int[]&nbsp;pixels,
           boolean&nbsp;transparency,
           int&nbsp;offset,
           int&nbsp;scanlength,
           int&nbsp;x,
           int&nbsp;y,
           int&nbsp;width,
           int&nbsp;height,
           int&nbsp;manipulation,
           int&nbsp;format)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies or draws the pixel data directly to the graphics context to a
 specific location from the array starting from the specified offset.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/nokia/mid/ui/DirectGraphics.html#drawPixels(short[], boolean, int, int, int, int, int, int, int, int)">drawPixels</A></B>(short[]&nbsp;pixels,
           boolean&nbsp;transparency,
           int&nbsp;offset,
           int&nbsp;scanlength,
           int&nbsp;x,
           int&nbsp;y,
           int&nbsp;width,
           int&nbsp;height,
           int&nbsp;manipulation,
           int&nbsp;format)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies or draws the pixel data directly to the graphics context to
 specific a location. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/nokia/mid/ui/DirectGraphics.html#drawPolygon(int[], int, int[], int, int, int)">drawPolygon</A></B>(int[]&nbsp;xPoints,
            int&nbsp;xOffset,
            int[]&nbsp;yPoints,
            int&nbsp;yOffset,
            int&nbsp;nPoints,
            int&nbsp;argbColor)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Draws a closed polygon defined by the arrays of the x- and
  y-coordinates.
  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/nokia/mid/ui/DirectGraphics.html#drawTriangle(int, int, int, int, int, int, int)">drawTriangle</A></B>(int&nbsp;x1,
             int&nbsp;y1,
             int&nbsp;x2,
             int&nbsp;y2,
             int&nbsp;x3,
             int&nbsp;y3,
             int&nbsp;argbColor)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Draws a closed triangle defined by coordinates.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/nokia/mid/ui/DirectGraphics.html#fillPolygon(int[], int, int[], int, int, int)">fillPolygon</A></B>(int[]&nbsp;xPoints,
            int&nbsp;xOffset,
            int[]&nbsp;yPoints,
            int&nbsp;yOffset,
            int&nbsp;nPoints,
            int&nbsp;argbColor)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fills a closed polygon defined by the arrays of the x- and
  y-coordinates.
  </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/nokia/mid/ui/DirectGraphics.html#fillTriangle(int, int, int, int, int, int, int)">fillTriangle</A></B>(int&nbsp;x1,
             int&nbsp;y1,
             int&nbsp;x2,
             int&nbsp;y2,
             int&nbsp;x3,
             int&nbsp;y3,
             int&nbsp;argbColor)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fills a closed triangle defined by coordinates.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/nokia/mid/ui/DirectGraphics.html#getAlphaComponent()">getAlphaComponent</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the alpha component of the current color.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/nokia/mid/ui/DirectGraphics.html#getNativePixelFormat()">getNativePixelFormat</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the native pixel format of an implementation. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/nokia/mid/ui/DirectGraphics.html#getPixels(byte[], byte[], int, int, int, int, int, int, int)">getPixels</A></B>(byte[]&nbsp;pixels,
          byte[]&nbsp;transparencyMask,
          int&nbsp;offset,
          int&nbsp;scanlength,
          int&nbsp;x,
          int&nbsp;y,
          int&nbsp;width,
          int&nbsp;height,
          int&nbsp;format)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies the pixel (including any transparency mask) values of the
 graphics
 context from a specific location to an array of byte values. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/nokia/mid/ui/DirectGraphics.html#getPixels(int[], int, int, int, int, int, int, int)">getPixels</A></B>(int[]&nbsp;pixels,
          int&nbsp;offset,
          int&nbsp;scanlength,
          int&nbsp;x,
          int&nbsp;y,
          int&nbsp;width,
          int&nbsp;height,
          int&nbsp;format)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies the pixel values of the graphics context from a specific
 location to an array of int values. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/nokia/mid/ui/DirectGraphics.html#getPixels(short[], int, int, int, int, int, int, int)">getPixels</A></B>(short[]&nbsp;pixels,
          int&nbsp;offset,
          int&nbsp;scanlength,
          int&nbsp;x,
          int&nbsp;y,
          int&nbsp;width,
          int&nbsp;height,
          int&nbsp;format)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies the pixel values of the graphics context from a specific
 location to an array of short values. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/nokia/mid/ui/DirectGraphics.html#setARGBColor(int)">setARGBColor</A></B>(int&nbsp;argbColor)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the current color (and alpha) to the specified ARGB value
  (0xAARRGGBB). </TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Field Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="FLIP_HORIZONTAL"><!-- --></A><H3>
FLIP_HORIZONTAL</H3>
<PRE>
public static final int <B>FLIP_HORIZONTAL</B></PRE>
<DL>
<DD>Constant for horizontal image flipping.<p>
 Value 0x2000 is assigned to FLIP_HORIZONTAL.
<P>
<DL>
<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../../../com/nokia/mid/ui/DirectGraphics.html#drawImage(javax.microedition.lcdui.Image, int, int, int, int)"><CODE>drawImage(Image img, int x, int y, int anchor, int manipulation)</CODE></A>, 
<A HREF="../../../../constant-values.html#com.nokia.mid.ui.DirectGraphics.FLIP_HORIZONTAL">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FLIP_VERTICAL"><!-- --></A><H3>
FLIP_VERTICAL</H3>
<PRE>
public static final int <B>FLIP_VERTICAL</B></PRE>
<DL>
<DD>Constant for vertical image flipping.<p>
 Value 0x4000 is assigned to FLIP_VERTICAL.
<P>
<DL>
<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../../../com/nokia/mid/ui/DirectGraphics.html#drawImage(javax.microedition.lcdui.Image, int, int, int, int)"><CODE>drawImage(Image img, int x, int y, int anchor, int manipulation)</CODE></A>, 
<A HREF="../../../../constant-values.html#com.nokia.mid.ui.DirectGraphics.FLIP_VERTICAL">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="ROTATE_90"><!-- --></A><H3>
ROTATE_90</H3>
<PRE>
public static final int <B>ROTATE_90</B></PRE>
<DL>
<DD>Constant for rotating an image 90 degrees counter-clockwise. ROTATE_90
 can be multiplied using "(ROTATE_90 + ROTATE_90)". If rotate 
 constant is combined with flip, use
 brackets: "(ROTATE_90 * 2) | FLIP_VERTICAL".
 <p>
 (ROTATE_90 * 2) results in a 180 degree rotate.
 <br>
 (ROTATE_90 * 3) results in a 270 degree rotate.
 <p>
 Value 90 is assigned to ROTATE_90.
<P>
<DL>
<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../../../com/nokia/mid/ui/DirectGraphics.html#drawImage(javax.microedition.lcdui.Image, int, int, int, int)"><CODE>drawImage(Image img, int x, int y, int anchor, int manipulation)</CODE></A>, 
<A HREF="../../../../constant-values.html#com.nokia.mid.ui.DirectGraphics.ROTATE_90">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="ROTATE_180"><!-- --></A><H3>
ROTATE_180</H3>
<PRE>
public static final int <B>ROTATE_180</B></PRE>
<DL>
<DD>Constant for rotating an image 180 degrees counter-clockwise.
 ROTATE_180 = (2 * ROTATE_90).
 <p>
 Value 180 is assigned to ROTATE_180.
<P>
<DL>
<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../../../com/nokia/mid/ui/DirectGraphics.html#drawImage(javax.microedition.lcdui.Image, int, int, int, int)"><CODE>drawImage(Image img, int x, int y, int anchor, int manipulation)</CODE></A>, 
<A HREF="../../../../constant-values.html#com.nokia.mid.ui.DirectGraphics.ROTATE_180">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="ROTATE_270"><!-- --></A><H3>
ROTATE_270</H3>
<PRE>
public static final int <B>ROTATE_270</B></PRE>
<DL>
<DD>Constant for rotating an image 270 degrees counter-clockwise.
 ROTATE_180 = (3 * ROTATE_90).
 <p>
 Value 270 is assigned to ROTATE_270.
<P>
<DL>
<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../../../com/nokia/mid/ui/DirectGraphics.html#drawImage(javax.microedition.lcdui.Image, int, int, int, int)"><CODE>drawImage(Image img, int x, int y, int anchor, int manipulation)</CODE></A>, 
<A HREF="../../../../constant-values.html#com.nokia.mid.ui.DirectGraphics.ROTATE_270">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="TYPE_BYTE_1_GRAY"><!-- --></A><H3>
TYPE_BYTE_1_GRAY</H3>
<PRE>
public static final int <B>TYPE_BYTE_1_GRAY</B></PRE>
<DL>
<DD>1 bit format, 2 distinct color values (on/off), stored as
  a byte. 8 pixel values in a single byte, packed as closely
  as possible.
  The pixel data is presented horizontally from left to right.
  The scanlength and offset parameters for drawPixels and
  getPixels are given in the number of pixels, not
  as indices to the pixels array.
  <p>
  <pre>
  Consider the following 9x9 graphics context where '+' indicates
  that the pixels are set to the "on" position:

  "MSB"  = The most significant bit in a byte in the array that the
           data is copied to
  "LSB"  = The least significant bit in a byte
  "|"    = Byte bounds
  "Bit#" = the bits in the first row of the pixels array that the data
           is copied to

         MSB         LSB
  Bit#-> 0 1 2 3 4 5 6 7 0
  ------------------------
         + +           +|+
         + + +        |+ +
         + + + +    |  + +
         + + + + +|    + +
         + +   +|+ +   + +
         + +  |  + + + + +
         + +|      + + + +
         +|+         + + +|
         + +           +|+

  byte[] byteArray = new byte[11];

  getPixels(byteArray, null, 0, 9, 0, 0, 9, 9,
            TYPE_BYTE_1_GRAY);

  After this the byteArray contains the following
  values:

  byteArray[0]  = (byte) 0xC1; // binary 11000001
  byteArray[1]  = (byte) 0xF0; // binary 11110000
  byteArray[2]  = (byte) 0xFC; // binary 11111100
  byteArray[3]  = (byte) 0x7F; // binary 01111111
  byteArray[4]  = (byte) 0x3D; // binary 00111101
  byteArray[5]  = (byte) 0xDE; // binary 11011110
  byteArray[6]  = (byte) 0x7F; // binary 01111111
  byteArray[7]  = (byte) 0x1F; // binary 00011111
  byteArray[8]  = (byte) 0x87; // binary 10000111
  byteArray[9]  = (byte) 0xC1; // binary 11000001
  byteArray[10] = (byte) 0x80; // binary 10000000
  </pre>

  Note that only one bit was defined for the byte stored in
  index 10 of byteArray; all other bits in this byte were
  left unchanged.
  <p>
  Value 1 is assigned to TYPE_BYTE_1_GRAY.
<P>
<DL>
<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#com.nokia.mid.ui.DirectGraphics.TYPE_BYTE_1_GRAY">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="TYPE_BYTE_1_GRAY_VERTICAL"><!-- --></A><H3>
TYPE_BYTE_1_GRAY_VERTICAL</H3>
<PRE>
public static final int <B>TYPE_BYTE_1_GRAY_VERTICAL</B></PRE>
<DL>
<DD>1 bit format, 2 distinct color values (on/off), stored as
  a byte. 8 pixel values are stored in a single byte.
  The pixel data is presented in bytes in which each
  byte defines 8 vertically packed pixels. In each byte, the least
  significant bit defines the topmost pixel and the most significant
  bit, the lowermost pixel stored in the byte. These byte-packed pixels
  are arranged in columns from left to right.
  <p>
  The scanlength and offset parameters for drawPixels and getPixels are
  given in the number of pixels, not as indices to the pixels array. In
  TYPE_BYTE_1_GRAY_VERTICAL format, the scanlength is not an offset
  that is based on indices of a pixels array, it is an offset 
  between consecutive rows in the image representation of the 
  pixels array. In normal the normal use of  
  TYPE_BYTE_1_GRAY_VERTICAL, as in other formats,
  the scanlength is the width of the image stored in the pixels array.
  <p>  
  If the height of a given graphic context is not divisible by 8,
  there are overflow bits in bytes, which are used to store the last
  pixels of the last rows. These are left unchanged in getPixels 
  and drawPixels methods.
  <p>
  For example, the getPixels method works in TYPE_BYTE_1_GRAY_VERTICAL
  format in the following fashion: the bit_location starting
  from 0 indicates the most significant bit of the first byte
  of the array. A bit_location 7 thus indicates the least significant
  bit of the first byte of the array, and a bit_location 8 indicates
  the most significant bit of the second byte of the array.
  <pre>
  P((x1+x), (y1+y)) is stored in bit_location:
            (((((offset/scanlength)+y1)/8)*scanlength) +
            ((offset%scanlength)+x1))*8 + 7 - (((offset/scanlength)+
            y1)%8)
  for each P((x1+x), (y1+y)), 
                where (0 <= x1 < width) and (0 <= y1 < height).
  </pre>
  <p>
  <pre>
  Example 1:
 
  Consider the following 9x9 graphics context where '+' indicates
  that the pixels set to the "on" position:

  Byte#  0 1 2 3 4 5 6 7 8  Bit#
  ------------------------------
  LSB    + +           + +   7
         + + +         + +   6
         + + + +       + +   5
         + + + + +     + +   4
         + +   + + +   + +   3
         + +     + + + + +   2
         + +       + + + +   1
  MSB    + +         + + +   0
         + +           + +   7

  byte[] byteArray = new byte[18];

  getPixels(byteArray, null, 0, 9, 0, 0, 9, 9,
            TYPE_BYTE_1_GRAY_VERTICAL);

  After this, the byteArray contains following values:
 
  byteArray[0]  = (byte) 0xFF; // binary 11111111
  byteArray[1]  = (byte) 0xFF; // binary 11111111
  byteArray[2]  = (byte) 0x0E; // binary 00001110
  byteArray[3]  = (byte) 0x1C; // binary 00011100
  byteArray[4]  = (byte) 0x38; // binary 00111000
  byteArray[5]  = (byte) 0x70; // binary 01110000
  byteArray[6]  = (byte) 0xE0; // binary 11100000
  byteArray[7]  = (byte) 0xFF; // binary 11111111
  byteArray[8]  = (byte) 0xFF; // binary 11111111
  byteArray[9]  = (byte) 0x01; // binary 00000001
  byteArray[10] = (byte) 0x01; // binary 00000001
  byteArray[11] = (byte) 0x00; // binary 00000000
  byteArray[12] = (byte) 0x00; // binary 00000000
  byteArray[13] = (byte) 0x00; // binary 00000000
  byteArray[14] = (byte) 0x00; // binary 00000000
  byteArray[15] = (byte) 0x00; // binary 00000000
  byteArray[16] = (byte) 0x01; // binary 00000001
  byteArray[17] = (byte) 0x01; // binary 00000001
  </pre>

  Note that only one bit (LSB) was defined
  for the bytes stored in indices 9-17 of byteArray;
  all other bits in those bytes were left unchanged.
 
  <pre>
  Example 2:
    
  Consider the following 10x13 graphics context where '+' indicates
  the pixels set to the "on" position:
 
  x:   0 1 2 3 4 5 6 7 8 9    y: 
                              0 
                              1
                              2
                              3
               + + + + +      4
               + + + + +      5
               + + + + +      6
               + + + + +      7
               + + + + +      8
               + + + + +      9 
               + + + + +      10 
               + + + + +      11
               + + + + +      12
 
  byte [] ba = new byte [30]; // 2 * scanlength * 8 pixels
  int offset = 16;
  int scanlength = 15;
  int x = 4;
  int y = 4;
  int width = 5;
  int height = 9;
  int format = TYPE_BYTE_GRAY_1_VERTICAL;
 
  DirectGraphics dg = DirectUtils.getDirectGraphics(g);
  dg.getPixels (ba, null, offset, scanlength,
                 x, y, width, height, format);
 
  Now the ba array contains the following values:  
  ba[0] = (byte) 0x00;
   
  ba[1] = (byte) 0xFE; //bits 11111110
  same value for ba[1] to ba[5]
   
  ba[6] = (byte) 0x00;
  same value for ba[6] to ba[15]
   
  ba[16] = (byte) 0x03; //bits 00000011
  same value for ba[16] to ba[20]
   
  ba[21] = (byte) 0x00;
  same value for ba[21] to ba[29]
  
  Same as the following figure:
                           1 1 1 1 1 1
  x:   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5  y: 
                                        0 
         + + + + +                      1
         + + + + +                      2
         + + + + +                      3
         + + + + +                      4
         + + + + +                      5
         + + + + +                      6
         + + + + +                      7
         + + + + +                      8
         + + + + +                      9 
                                        10 
                                        11
                                        12
                                        13
                                        14
                                        15
  </pre>
  <p>
  Value -1 is assigned to TYPE_BYTE_1_GRAY_VERTICAL.
<P>
<DL>
<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#com.nokia.mid.ui.DirectGraphics.TYPE_BYTE_1_GRAY_VERTICAL">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="TYPE_BYTE_2_GRAY"><!-- --></A><H3>
TYPE_BYTE_2_GRAY</H3>
<PRE>
public static final int <B>TYPE_BYTE_2_GRAY</B></PRE>
<DL>
<DD>2 bit format, 4 gray scale colors. Stored as a byte,
  4 pixel values in a single byte.
  The pixel data is presented horizontally from left to right.
  <p>
  Value 2 is assigned to TYPE_BYTE_2_GRAY.
<P>
<DL>
<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#com.nokia.mid.ui.DirectGraphics.TYPE_BYTE_2_GRAY">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="TYPE_BYTE_4_GRAY"><!-- --></A><H3>
TYPE_BYTE_4_GRAY</H3>
<PRE>
public static final int <B>TYPE_BYTE_4_GRAY</B></PRE>
<DL>
<DD>4 bit format, 16 gray scale colors. Stored as a byte,
  2 pixel values in a single byte.
  The pixel data is presented horizontally from left to right.
  <p>
  Value 4 is assigned to TYPE_BYTE_4_GRAY.
<P>
<DL>
<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#com.nokia.mid.ui.DirectGraphics.TYPE_BYTE_4_GRAY">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="TYPE_BYTE_8_GRAY"><!-- --></A><H3>
TYPE_BYTE_8_GRAY</H3>
<PRE>
public static final int <B>TYPE_BYTE_8_GRAY</B></PRE>
<DL>
<DD>8 bit format, 256 gray scale colors. Stored as a byte,
  1 pixel value in a single byte.
  The pixel data is presented horizontally from left to right.
  <p>
  Value 8 is assigned to TYPE_BYTE_8_GRAY.
<P>
<DL>
<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#com.nokia.mid.ui.DirectGraphics.TYPE_BYTE_8_GRAY">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="TYPE_BYTE_332_RGB"><!-- --></A><H3>
TYPE_BYTE_332_RGB</H3>
<PRE>
public static final int <B>TYPE_BYTE_332_RGB</B></PRE>
<DL>
<DD>3 bits for red, 3 bits for green, and 2 bits for blue component
  in a pixel, stored as a byte.
  The pixel data is presented horizontally from left to right.
  <p>
  Value 332 is assigned to TYPE_BYTE_332_RGB.
<P>
<DL>
<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#com.nokia.mid.ui.DirectGraphics.TYPE_BYTE_332_RGB">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="TYPE_USHORT_4444_ARGB"><!-- --></A><H3>
TYPE_USHORT_4444_ARGB</H3>
<PRE>
public static final int <B>TYPE_USHORT_4444_ARGB</B></PRE>
<DL>
<DD>4 bits for alpha, red, green and blue component in a pixel, stored as
  a short (0xARGB).
  <p>
  Value 4444 is assigned to TYPE_USHORT_4444_ARGB.
<P>
<DL>
<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#com.nokia.mid.ui.DirectGraphics.TYPE_USHORT_4444_ARGB">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="TYPE_USHORT_444_RGB"><!-- --></A><H3>
TYPE_USHORT_444_RGB</H3>
<PRE>
public static final int <B>TYPE_USHORT_444_RGB</B></PRE>
<DL>
<DD>4 bits for red, green and blue component in a pixel, stored as a
  short (0x0RGB).
  <p>
  Value 444 is assigned to TYPE_USHORT_444_RGB.
<P>
<DL>
<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#com.nokia.mid.ui.DirectGraphics.TYPE_USHORT_444_RGB">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="TYPE_USHORT_555_RGB"><!-- --></A><H3>
TYPE_USHORT_555_RGB</H3>
<PRE>
public static final int <B>TYPE_USHORT_555_RGB</B></PRE>
<DL>
<DD>5 bits for red, green and blue component in a pixel.
  <p>
  Value 555 is assigned to TYPE_USHORT_555_RGB.
<P>
<DL>
<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#com.nokia.mid.ui.DirectGraphics.TYPE_USHORT_555_RGB">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="TYPE_USHORT_1555_ARGB"><!-- --></A><H3>
TYPE_USHORT_1555_ARGB</H3>
<PRE>
public static final int <B>TYPE_USHORT_1555_ARGB</B></PRE>
<DL>
<DD>1 bit for alpha, 5 bits for red, green and blue component in a pixel.
  <p>
  Value 1555 is assigned to TYPE_USHORT_1555_ARGB.
<P>
<DL>
<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#com.nokia.mid.ui.DirectGraphics.TYPE_USHORT_1555_ARGB">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="TYPE_USHORT_565_RGB"><!-- --></A><H3>
TYPE_USHORT_565_RGB</H3>
<PRE>
public static final int <B>TYPE_USHORT_565_RGB</B></PRE>
<DL>
<DD>5 bits for red, 6 bits for green and 5 bits for blue component in a
  pixel.
  <p>
  Value 565 is assigned to TYPE_USHORT_565_RGB.
<P>
<DL>
<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#com.nokia.mid.ui.DirectGraphics.TYPE_USHORT_565_RGB">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="TYPE_INT_888_RGB"><!-- --></A><H3>
TYPE_INT_888_RGB</H3>
<PRE>
public static final int <B>TYPE_INT_888_RGB</B></PRE>
<DL>
<DD>8 bits for red, green and blue component in a pixel (0x00RRGGBB).
  The high order byte (alpha) is ignored by the implementation.
  <p>
  Value 888 is assigned to TYPE_INT_888_RGB.
<P>
<DL>
<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#com.nokia.mid.ui.DirectGraphics.TYPE_INT_888_RGB">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="TYPE_INT_8888_ARGB"><!-- --></A><H3>
TYPE_INT_8888_ARGB</H3>
<PRE>
public static final int <B>TYPE_INT_8888_ARGB</B></PRE>
<DL>
<DD>8 bits for alpha, red, green and blue component in a pixel
  (0xAARRGGBB).
  <p>
  Value 8888 is assigned to TYPE_INT_8888_ARGB.
<P>
<DL>
<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#com.nokia.mid.ui.DirectGraphics.TYPE_INT_8888_ARGB">Constant Field Values</A></DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->


<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Method Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="setARGBColor(int)"><!-- --></A><H3>
setARGBColor</H3>
<PRE>
public void <B>setARGBColor</B>(int&nbsp;argbColor)</PRE>
<DL>
<DD>Sets the current color (and alpha) to the specified ARGB value
  (0xAARRGGBB). All subsequent rendering operations will use this color 
  (and alpha) in associated Graphics.
  <p>
  Note that since all rendering 
  operations defined in DirectGraphics define the color value as a 
  parameter in the call, using this method affects only rendering 
  operations of Graphics class. It should also be noted that the use of 
  this method is reasonable only if alpha blending is supported by the 
  device in Graphics operations.
  <p>
  For setting a fully opaque drawing 
  color applications should use methods of Graphics class, like 
  Graphics setColor(int RGB).
  <p>
  See also <a href="#setcoloralpha">note about relation to Graphics  
  set color methods</a>. High-order byte specifies opacity; that 
  is, 0x00xxxxxx specifies a 
  fully transparent pixel and 0xffxxxxxx specifies a fully opaque 
  pixel. Implementations 
  must treat any pixel with a nonzero top byte as being non-
  transparent. I.e. If alpha-blending is not supported then non-zero 
  top byte means a fully opaque color. Most implementations treat non-
  zero top byte as fully opaque, i.e. alpha blending is not 
  implemented.
  <p>
  Note: Following two calls both results a fully transparent red color, 
  i.e. nothing is drawn:
  <pre>
     setARGBColor(0xFF0000);
     setARGBColor(0x00FF0000);
  </pre>
  <p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>argbColor</CODE> - the color being set<DT><B>Since:</B></DT>
  <DD>1.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="drawImage(javax.microedition.lcdui.Image, int, int, int, int)"><!-- --></A><H3>
drawImage</H3>
<PRE>
public void <B>drawImage</B>(javax.microedition.lcdui.Image&nbsp;img,
                      int&nbsp;x,
                      int&nbsp;y,
                      int&nbsp;anchor,
                      int&nbsp;manipulation)</PRE>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>As of Nokia UI API 1.1 in devices with MIDP 2.0 or higher, replaced by javax.microedition.lcdui.Graphics.drawRegion(javax.microedition.lcdui.Image, int, int, int, int, int, int, int, int).</I>
<P>
<DD>Draws an image to the graphics context. Does common image
 manipulations
 during the drawing of an image. Manipulation
 can be 0 if no manipulation is done. Draws the
 specified image by using the anchor point - the anchor point is
 applied
 after the manipulation. Anchor values are defined in <CODE>Graphics</CODE>.
 The image can be drawn in different positions relative to the 
 anchor point by
 passing the appropriate position constants.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>img</CODE> - the image specified to be drawn<DD><CODE>x</CODE> - the x-coordinate of the anchor point<DD><CODE>y</CODE> - the y-coordinate of the anchor point<DD><CODE>anchor</CODE> - the anchor point for positioning the image<DD><CODE>manipulation</CODE> - flip or rotate value or a combination of values, 0
        if none
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if anchor is not a legal
             value or manipulation is not supported
<DD><CODE>java.lang.NullPointerException</CODE> - if img is null<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><CODE>Image</CODE>, 
<A HREF="../../../../com/nokia/mid/ui/DirectGraphics.html#FLIP_VERTICAL"><CODE>FLIP_VERTICAL</CODE></A>, 
<A HREF="../../../../com/nokia/mid/ui/DirectGraphics.html#FLIP_HORIZONTAL"><CODE>FLIP_HORIZONTAL</CODE></A>, 
<A HREF="../../../../com/nokia/mid/ui/DirectGraphics.html#ROTATE_90"><CODE>ROTATE_90</CODE></A>, 
<A HREF="../../../../com/nokia/mid/ui/DirectGraphics.html#ROTATE_180"><CODE>ROTATE_180</CODE></A>, 
<A HREF="../../../../com/nokia/mid/ui/DirectGraphics.html#ROTATE_270"><CODE>ROTATE_270</CODE></A>, 
"Anchor definitions in Graphics"</DL>
</DD>
</DL>
<HR>

<A NAME="drawTriangle(int, int, int, int, int, int, int)"><!-- --></A><H3>
drawTriangle</H3>
<PRE>
public void <B>drawTriangle</B>(int&nbsp;x1,
                         int&nbsp;y1,
                         int&nbsp;x2,
                         int&nbsp;y2,
                         int&nbsp;x3,
                         int&nbsp;y3,
                         int&nbsp;argbColor)</PRE>
<DL>
<DD>Draws a closed triangle defined by coordinates.
 <p>
 Note that the method uses the color passed as a parameter for drawing
 the
 triangle and <i>not</i> the current active color of graphics context.
 The call does not change the current active drawing color of the
 graphics context.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x1</CODE> - the x-coordinate of the first vertex<DD><CODE>y1</CODE> - the y-coordinate of the first vertex<DD><CODE>x2</CODE> - the x-coordinate of the second vertex<DD><CODE>y2</CODE> - the y-coordinate of the second vertex<DD><CODE>x3</CODE> - the x-coordinate of the third vertex<DD><CODE>y3</CODE> - the y-coordinate of the third vertex<DD><CODE>argbColor</CODE> - the ARGB color value used in painting the triangle<DT><B>Since:</B></DT>
  <DD>1.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="fillTriangle(int, int, int, int, int, int, int)"><!-- --></A><H3>
fillTriangle</H3>
<PRE>
public void <B>fillTriangle</B>(int&nbsp;x1,
                         int&nbsp;y1,
                         int&nbsp;x2,
                         int&nbsp;y2,
                         int&nbsp;x3,
                         int&nbsp;y3,
                         int&nbsp;argbColor)</PRE>
<DL>
<DD>Fills a closed triangle defined by coordinates.
 <p>
 Note that the method uses the color passed as a parameter for drawing
 the
 triangle and <i>not</i> the current active color of the graphics
 context.
 The call does not change the current active drawing color of the
 graphics
 context.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x1</CODE> - the x-coordinate of the first vertex<DD><CODE>y1</CODE> - the y-coordinate of the first vertex<DD><CODE>x2</CODE> - the x-coordinate of the second vertex<DD><CODE>y2</CODE> - the y-coordinate of the second vertex<DD><CODE>x3</CODE> - the x-coordinate of the third vertex<DD><CODE>y3</CODE> - the y-coordinate of the third vertex<DD><CODE>argbColor</CODE> - the ARGB color value used in painting the triangle<DT><B>Since:</B></DT>
  <DD>1.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="drawPolygon(int[], int, int[], int, int, int)"><!-- --></A><H3>
drawPolygon</H3>
<PRE>
public void <B>drawPolygon</B>(int[]&nbsp;xPoints,
                        int&nbsp;xOffset,
                        int[]&nbsp;yPoints,
                        int&nbsp;yOffset,
                        int&nbsp;nPoints,
                        int&nbsp;argbColor)</PRE>
<DL>
<DD>Draws a closed polygon defined by the arrays of the x- and
  y-coordinates.
  Each pair of (x, y) coordinates defines a point.
  <p>
  This method draws the polygon defined by nPoint line segments,
  where the first nPoint - 1 line segments are line segments from
  (xPoints[xOffset + i - 1], yPoints[yOffset + i - 1]) to
  (xPoints[xOffset + i], yPoints[yOffset + i]),
  for 1 <= i <= nPoints. The figure is automatically closed by drawing
  a line connecting the final point to the first point if those points
  are different.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>xPoints</CODE> - an array of x-coordinates<DD><CODE>xOffset</CODE> - an offset to first x point in xPoints<DD><CODE>yPoints</CODE> - an array of y-coordinates<DD><CODE>yOffset</CODE> - an offset to first y point in yPoints<DD><CODE>nPoints</CODE> - the total number of points<DD><CODE>argbColor</CODE> - the ARGB color value used in painting the polygon
<DT><B>Throws:</B>
<DD><CODE>java.lang.NullPointerException</CODE> - if xPoints or yPoints array is null.
<DD><CODE>java.lang.ArrayIndexOutOfBoundsException</CODE> - if requested to access xPoints
                                         or
  yPoints beyond the length of the arrays or with a negative index<DT><B>Since:</B></DT>
  <DD>1.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="fillPolygon(int[], int, int[], int, int, int)"><!-- --></A><H3>
fillPolygon</H3>
<PRE>
public void <B>fillPolygon</B>(int[]&nbsp;xPoints,
                        int&nbsp;xOffset,
                        int[]&nbsp;yPoints,
                        int&nbsp;yOffset,
                        int&nbsp;nPoints,
                        int&nbsp;argbColor)</PRE>
<DL>
<DD>Fills a closed polygon defined by the arrays of the x- and
  y-coordinates.
  <p>
  This method draws the polygon defined by nPoint line segments,
  where the first nPoint - 1 line segments are line segments from
  (xPoints[xOffset + i - 1], yPoints[yOffset + i - 1]) to
  (xPoints[xOffset + i], yPoints[yOffset + i]),
  for 1 <= i <= nPoints. The figure is automatically closed by
  drawing a line connecting the final point to the first point
  if those points are different.
  <p>
  The area inside the polygon is defined using an even-odd fill
  rule, which is also known as the alternating rule.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>xPoints</CODE> - an array of x-coordinates<DD><CODE>xOffset</CODE> - an offset to first x point in xPoints<DD><CODE>yPoints</CODE> - an array of y-coordinates<DD><CODE>yOffset</CODE> - an offset to first y point in yPoints<DD><CODE>nPoints</CODE> - the total number of points<DD><CODE>argbColor</CODE> - the ARGB color value used in painting the polygon
<DT><B>Throws:</B>
<DD><CODE>java.lang.NullPointerException</CODE> - if xPoints or yPoints array is null.
<DD><CODE>java.lang.ArrayIndexOutOfBoundsException</CODE> - if requested to access xPoints
  or yPoints beyond the length of the arrays or with a negative 
  index<DT><B>Since:</B></DT>
  <DD>1.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="drawPixels(int[], boolean, int, int, int, int, int, int, int, int)"><!-- --></A><H3>
drawPixels</H3>
<PRE>
public void <B>drawPixels</B>(int[]&nbsp;pixels,
                       boolean&nbsp;transparency,
                       int&nbsp;offset,
                       int&nbsp;scanlength,
                       int&nbsp;x,
                       int&nbsp;y,
                       int&nbsp;width,
                       int&nbsp;height,
                       int&nbsp;manipulation,
                       int&nbsp;format)</PRE>
<DL>
<DD>Copies or draws the pixel data directly to the graphics context to a
 specific location from the array starting from the specified offset.
 The
 pixels are passed in the format defined by the format parameter. If
 an implementation does not support the format, an
 IllegalArgumentException
 is thrown.
 <p>
 This method accepts only int-based formats. Passing all other
 formats will result in an IllegalArgumentException.
 Note that it is possible that no int-based pixel format is supported
 by an implementation.
 <p>
 The operation is subject to the current clip region and translation
 for
 this Graphics object.
 <p>
 The boolean
 value transparency will indicate whether the pixel's transparency
 value
 will be checked. If the transparency argument is false, the pixels are
 set
 to the graphics context without comparing the transparency values. If
 the
 transparency argument is true, the pixel's transparency value is
 checked
 and it will affect the drawing of a pixel.
 <p>
 The drawPixels paints the pixel data in the graphics context in the
 following fashion:
 <pre>
 P(x1, y1) = pixels[offset + (x1 - x) + (y1 - y) * scanlength],
 for each P(x1, y1), where (x <= x1 < x + width) and (y <= y1 < y +
 height).
 </pre>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pixels</CODE> - an array of pixel values (0xAARRGGBB)<DD><CODE>transparency</CODE> - true if the pixel's transparency value will be
        checked<DD><CODE>offset</CODE> - the index of the first pixel value<DD><CODE>scanlength</CODE> - the relative array offset between the corresponding
 pixels in consecutive rows<DD><CODE>x</CODE> - the horizontal rendering location in the graphics context<DD><CODE>y</CODE> - the vertical rendering location in the graphics context<DD><CODE>width</CODE> - the width of the region to be rendered<DD><CODE>height</CODE> - the height of the region to be rendered<DD><CODE>manipulation</CODE> - the manipulation done to the image before the
 draw, 0 means none.<DD><CODE>format</CODE> - the format which the pixels are provided in
<DT><B>Throws:</B>
<DD><CODE>java.lang.NullPointerException</CODE> - if pixels is null
<DD><CODE>java.lang.ArrayIndexOutOfBoundsException</CODE> - if requested to
 access
 pixels beyond the length of array or with negative index
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if manipulation is unknown,
 width or height is negative, or the format is wrong or unsupported<DT><B>Since:</B></DT>
  <DD>1.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="drawPixels(byte[], byte[], int, int, int, int, int, int, int, int)"><!-- --></A><H3>
drawPixels</H3>
<PRE>
public void <B>drawPixels</B>(byte[]&nbsp;pixels,
                       byte[]&nbsp;transparencyMask,
                       int&nbsp;offset,
                       int&nbsp;scanlength,
                       int&nbsp;x,
                       int&nbsp;y,
                       int&nbsp;width,
                       int&nbsp;height,
                       int&nbsp;manipulation,
                       int&nbsp;format)</PRE>
<DL>
<DD>Copies or draws the pixel data directly to the graphics context to a
 specific location. The pixels are
 passed in the format defined by the format parameter. If an
 implementation
 does not support the format, an IllegalArgumentException is thrown.
 <p>
 This method accepts only byte-based formats. Passing all other
 formats will result in an IllegalArgumentException.
 <p>
 The operation is subject to the current clip region and
 translation for this Graphics object.
 Bytes in pixels and transparencyMask arrays will be passed in
 the same format. The transparencyMask can be null. If the transparency
 mask is null, the image is considered fully opaque. For pixel formats
 TYPE_BYTE_1_GRAY and TYPE_BYTE_1_GRAY_VERTICAL bit value 0 means fully
 transparent pixel, 1 means fully opaque pixel. For other byte formats
 the transparency information is as wide as color information for one
 pixel, for example, in TYPE_BYTE_2_GRAY 2 bits are used for stroring
 transparency information in transparencyMask. The semantics for
 mask values are same as in <a href="#Alpha">alpha channel</a>
 use. Zero value indicates fully
 transparent pixel, non-zero values are treated as non-transparent
 (largest possible value means fully opaque and values in between
 either fully opaque or semi-opaque).
 <p>
 Note that scanlength and offset parameters indicate the
 scanlength and offset in number of pixels. This is not necessarily the
 same as array indices since multiple pixels may be stored in a byte.
 <p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pixels</CODE> - an array of pixel values<DD><CODE>transparencyMask</CODE> - an array defining the transparency mask<DD><CODE>offset</CODE> - the index of the first pixel and the mask value<DD><CODE>scanlength</CODE> - the relative array offset between the corresponding
 pixels and the mask value in consecutive rows<DD><CODE>x</CODE> - the horizontal rendering location in the graphics context<DD><CODE>y</CODE> - the vertical rendering location in the graphics context<DD><CODE>width</CODE> - the width of the region to be rendered<DD><CODE>height</CODE> - the height of the region to be rendered<DD><CODE>manipulation</CODE> - the manipulation done to the image before the
 draw, 0 means none.<DD><CODE>format</CODE> - the format which the pixels are provided in
<DT><B>Throws:</B>
<DD><CODE>java.lang.NullPointerException</CODE> - if pixels is null
<DD><CODE>java.lang.ArrayIndexOutOfBoundsException</CODE> - if requested to
 access
 beyond the length of array or with negative index
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if manipulation is unknown,
 width or height is negative, or the format is wrong or unsupported<DT><B>Since:</B></DT>
  <DD>1.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="drawPixels(short[], boolean, int, int, int, int, int, int, int, int)"><!-- --></A><H3>
drawPixels</H3>
<PRE>
public void <B>drawPixels</B>(short[]&nbsp;pixels,
                       boolean&nbsp;transparency,
                       int&nbsp;offset,
                       int&nbsp;scanlength,
                       int&nbsp;x,
                       int&nbsp;y,
                       int&nbsp;width,
                       int&nbsp;height,
                       int&nbsp;manipulation,
                       int&nbsp;format)</PRE>
<DL>
<DD>Copies or draws the pixel data directly to the graphics context to
 specific a location. The pixels are
 passed in the format defined by the format parameter. If an
 implementation
 does not support the format, an IllegalArgumentException is thrown.
 <p>
 This method accepts only short-based formats. Passing all other
 formats will result in an IllegalArgumentException.
 Note that it is possible that no short-based pixel format is
 supported by an implementation.
 <p>
 The operation is subject to the current clip region and
 translation for this Graphics object.
 The boolean
 value transparency will indicate whether the pixel's transparency
 value will be checked. If the transparency argument is false, the 
 pixels are set to the graphics context without comparing the 
 transparency values.
 If the transparency argument is true, the pixel's transparency value
 is checked and it will affect the drawing of a pixel.
 <p>
 The drawPixels paints the pixel data in the graphics context in the
 following fashion:
 <pre>
 P(x1, y1) = pixels[offset + (x1 - x) + (y1 - y) * scanlength],
 for each P(x1, y1), where (x <= x1 < x + width) and (y <= y1 < y +
 height).
 </pre>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pixels</CODE> - an array of pixel values<DD><CODE>transparency</CODE> - true if the pixel's transparency value will be
        checked<DD><CODE>offset</CODE> - the index of the first pixel value<DD><CODE>scanlength</CODE> - the relative array offset between the corresponding
 pixels in consecutive rows<DD><CODE>x</CODE> - the horizontal rendering location in the graphics context<DD><CODE>y</CODE> - the vertical rendering location in the graphics context<DD><CODE>width</CODE> - the width of the region to be rendered<DD><CODE>height</CODE> - the height of the region to be rendered<DD><CODE>manipulation</CODE> - the manipulation done to the image before the
        draw, 0 means none.<DD><CODE>format</CODE> - the format which the pixels are provided in
<DT><B>Throws:</B>
<DD><CODE>java.lang.NullPointerException</CODE> - if pixels is null
<DD><CODE>java.lang.ArrayIndexOutOfBoundsException</CODE> - if requested to
         access beyond the length of array or with negative index
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if manipulation is unknown,
 width or height is negative, or the format is wrong or unsupported<DT><B>Since:</B></DT>
  <DD>1.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getPixels(int[], int, int, int, int, int, int, int)"><!-- --></A><H3>
getPixels</H3>
<PRE>
public void <B>getPixels</B>(int[]&nbsp;pixels,
                      int&nbsp;offset,
                      int&nbsp;scanlength,
                      int&nbsp;x,
                      int&nbsp;y,
                      int&nbsp;width,
                      int&nbsp;height,
                      int&nbsp;format)</PRE>
<DL>
<DD>Copies the pixel values of the graphics context from a specific
 location to an array of int values. The pixels will
 be passed in the format defined by format parameter. If an
 implementation
 does not support the format, an IllegalArgumentException is thrown.
 Note that it is possible that only the native format is supported
 via the appropriate version of getPixels method.
 <p>
 This method returns only int-based formats. Requesting all other
 formats will result in an IllegalArgumentException.
 <p>
 Throws
 ArrayIndexOutOfBoundsException if array size is too small for image
 pixels.
 <p>
 The current clip region does not affect pixel values stored
 in the pixels array, i.e. even if a clip region is set and the region
 intersects the region queried with this method, also the clip 
 region pixels are stored in the pixels array. The 
 operation <i>is</i> subject to the current translation for this 
 Graphics object.
 <p>
 The getPixels methods stores the pixel data to the pixels array in the
 following fashion:
 <pre>
 pixels[offset + (x1 - x) + (y1 - y) * scanlength] = P(x1, y1),
 for each P(x1, y1), where (x <= x1 < x + width) and (y <= y1 < y +
 height).
 </pre>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pixels</CODE> - an array which the pixel information will be stored in<DD><CODE>offset</CODE> - the index to the pixels array where the first pixel
       value will be stored<DD><CODE>scanlength</CODE> - the relative offset in the pixels array between
 corresponding pixels in consecutive rows<DD><CODE>x</CODE> - the x-coordinate of the upper left corner of the region in
 the graphics context<DD><CODE>y</CODE> - the y-coordinate of the upper left corner of the region in
 the graphics context<DD><CODE>width</CODE> - the width of the region in graphics context<DD><CODE>height</CODE> - the height of the region in graphics context<DD><CODE>format</CODE> - the format which the pixels are requested in
<DT><B>Throws:</B>
<DD><CODE>java.lang.NullPointerException</CODE> - if pixels is null
<DD><CODE>java.lang.ArrayIndexOutOfBoundsException</CODE> - if array size is too
         small for the image pixels or negative index access is 
         attempted, contents of the array remain unchanged
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if x, y, width or height is
 negative, or the format is wrong or unsupported<DT><B>Since:</B></DT>
  <DD>1.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getPixels(byte[], byte[], int, int, int, int, int, int, int)"><!-- --></A><H3>
getPixels</H3>
<PRE>
public void <B>getPixels</B>(byte[]&nbsp;pixels,
                      byte[]&nbsp;transparencyMask,
                      int&nbsp;offset,
                      int&nbsp;scanlength,
                      int&nbsp;x,
                      int&nbsp;y,
                      int&nbsp;width,
                      int&nbsp;height,
                      int&nbsp;format)</PRE>
<DL>
<DD>Copies the pixel (including any transparency mask) values of the
 graphics
 context from a specific location to an array of byte values. The
 pixels
 will be passed in the format defined by format parameter. If an
 implementation doesn't support the format an IllegalArgumentException
 is thrown.
 <p>
 This method returns only byte-based formats. Requesting all other
 formats will result in an IllegalArgumentException.
 <p>

 <p>
 Throws
 ArrayIndexOutOfBoundsException if array size is too small for image
 pixels or transparency mask.
 The argument transparencyMask can be null if the caller is not
 interested in getting the mask. See
 <A HREF="../../../../com/nokia/mid/ui/DirectGraphics.html#drawPixels(byte[], byte[], int, int, int, int, int, int, int, int)"><CODE>transparencyMask</CODE></A> definition on drawPixels(...).
 <p>
 Note that the scanlength and offset parameters indicate the
 scanlength and offset in number of pixels. This is not necessarily the
 same as array indices since multiple pixels may be stored in a byte.
 <p>
 The current clip region does not affect pixel values stored
 in the pixels array, i.e. even if a clip region is set and the region
 intersects the region queried with this method, also the clip 
 region pixels are stored in the pixels array. The 
 operation <i>is</i> subject to the current translation for this 
 Graphics object.
 <p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pixels</CODE> - an array which the pixel information will be stored in<DD><CODE>transparencyMask</CODE> - an array which the transparency mask will be
 stored in<DD><CODE>offset</CODE> - offset in the array where the first pixel and mask value
 will be stored<DD><CODE>scanlength</CODE> - the relative offset in the array between the
 corresponding pixels and the mask value in consecutive rows<DD><CODE>x</CODE> - the x-coordinate of the upper left corner of the region in
 the graphics context<DD><CODE>y</CODE> - the y-coordinate of the upper left corner of the region in
 the graphics context<DD><CODE>width</CODE> - the width of the region in the graphics context<DD><CODE>height</CODE> - the height of the region in the graphics context<DD><CODE>format</CODE> - the format which the pixels are requested in
<DT><B>Throws:</B>
<DD><CODE>java.lang.NullPointerException</CODE> - if pixels is null
<DD><CODE>java.lang.ArrayIndexOutOfBoundsException</CODE> - if array size is too
         small
 for the image pixels or negative index access is attempted, contents
 of the array remain unchanged
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if x, y, width or height is
 negative, or the format is wrong or unsupported<DT><B>Since:</B></DT>
  <DD>1.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getPixels(short[], int, int, int, int, int, int, int)"><!-- --></A><H3>
getPixels</H3>
<PRE>
public void <B>getPixels</B>(short[]&nbsp;pixels,
                      int&nbsp;offset,
                      int&nbsp;scanlength,
                      int&nbsp;x,
                      int&nbsp;y,
                      int&nbsp;width,
                      int&nbsp;height,
                      int&nbsp;format)</PRE>
<DL>
<DD>Copies the pixel values of the graphics context from a specific
 location to an array of short values. The pixels will
 be passed in the format defined by format parameter. If an
 implementation
 does not support the format, an IllegalArgumentException is thrown.
 Note that it is possible that only the native format is supported
 via the appropriate version of getPixels method.
 <p>
 This method returns only short-based formats. Requesting all other
 formats will result in an IllegalArgumentException.
 <p>
 Throws ArrayIndexOutOfBoundsException if array size is
 too small for image pixels.
 <p>
 The current clip region does not affect pixel values stored
 in the pixels array, i.e. even if a clip region is set and the region
 intersects the region queried with this method, also the clip 
 region pixels are stored in the pixels array. The 
 operation <i>is</i> subject to the current translation for this 
 Graphics object.
 <p>
 The getPixels methods stores the pixel data to the pixels array in the
 following fashion:
 <pre>
 pixels[offset + (x1 - x) + (y1 - y) * scanlength] = P(x1, y1),
 for each P(x1, y1), where (x <= x1 < x + width) and (y <= y1 < y +
 height).
 </pre>
 <p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pixels</CODE> - an array which the pixel information will be stored in<DD><CODE>offset</CODE> - the index in the array where the first pixel value will
        be stored<DD><CODE>scanlength</CODE> - the relative offset in the array between the
 corresponding pixels in consecutive rows<DD><CODE>x</CODE> - the x-coordinate of the upper left corner of the region in
 the graphics context<DD><CODE>y</CODE> - the y-coordinate of the upper left corner of the region in
 the graphics context<DD><CODE>width</CODE> - the width of the region in the graphics context<DD><CODE>height</CODE> - the height of the region in the graphics context<DD><CODE>format</CODE> - the format which the pixels are requested in
<DT><B>Throws:</B>
<DD><CODE>java.lang.NullPointerException</CODE> - if pixels is null
<DD><CODE>java.lang.ArrayIndexOutOfBoundsException</CODE> - if array size is too
         small for the image pixels or negative index access is 
         attempted, contents of the array remain unchanged
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if x, y, width or height is
 negative, or the format is wrong or unsupported<DT><B>Since:</B></DT>
  <DD>1.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getNativePixelFormat()"><!-- --></A><H3>
getNativePixelFormat</H3>
<PRE>
public int <B>getNativePixelFormat</B>()</PRE>
<DL>
<DD>Returns the native pixel format of an implementation. The method
 returns the pixel format, for example,
 <A HREF="../../../../com/nokia/mid/ui/DirectGraphics.html#TYPE_BYTE_1_GRAY"><CODE>TYPE_BYTE_1_GRAY</CODE></A> or
 <A HREF="../../../../com/nokia/mid/ui/DirectGraphics.html#TYPE_USHORT_4444_ARGB"><CODE>TYPE_USHORT_4444_ARGB</CODE></A>.
 The native format is the most efficient format supported by the
 drawPixels
 and getPixels methods of specific implementation. An implementation
 must support
 the format that it returns from this method. Implementation may
 support
 also other pixel formats.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the native format of specific implementation.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getAlphaComponent()"><!-- --></A><H3>
getAlphaComponent</H3>
<PRE>
public int <B>getAlphaComponent</B>()</PRE>
<DL>
<DD>Gets the alpha component of the current color.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>integer value in range 0-255<DT><B>Since:</B></DT>
  <DD>1.0</DD>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>

<!-- ========== START OF NAVBAR ========== -->
<A NAME="navbar_bottom"><!-- --></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<a href=http://forum.nokia.com/java target=_top>forum.nokia.com/java</a></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;PREV CLASS&nbsp;
&nbsp;NEXT CLASS</FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../index.html" TARGET="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="DirectGraphics.html" TARGET="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;
<SCRIPT>
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html" TARGET=""><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
<A HREF="../../../../allclasses-noframe.html" TARGET=""><B>All Classes</B></A>
</NOSCRIPT>
</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<!-- =========== END OF NAVBAR =========== -->

<HR>
<font size=-1>Copyright (c) 2002-2004 Nokia Corporation.  All Rights Reserved.<br>Java is a trademark or registered trademark of Sun Microsystems, Inc.</font>
</BODY>
</HTML>
